/* automatically generated by rust-bindgen 0.54.1 */

#![allow(warnings)]
use std::fmt::Debug;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const DEFINE_NO_DEPRECATED: u32 = 0;
pub const hipblasVersionMajor: u32 = 0;
pub const hipblaseVersionMinor: u32 = 28;
pub const hipblasVersionPatch: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const __HIP_ARCH_HAS_GLOBAL_INT32_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_GLOBAL_FLOAT_ATOMIC_EXCH__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_INT32_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_FLOAT_ATOMIC_EXCH__: u32 = 0;
pub const __HIP_ARCH_HAS_FLOAT_ATOMIC_ADD__: u32 = 0;
pub const __HIP_ARCH_HAS_GLOBAL_INT64_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_SHARED_INT64_ATOMICS__: u32 = 0;
pub const __HIP_ARCH_HAS_DOUBLES__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_VOTE__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_BALLOT__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_SHUFFLE__: u32 = 0;
pub const __HIP_ARCH_HAS_WARP_FUNNEL_SHIFT__: u32 = 0;
pub const __HIP_ARCH_HAS_THREAD_FENCE_SYSTEM__: u32 = 0;
pub const __HIP_ARCH_HAS_SYNC_THREAD_EXT__: u32 = 0;
pub const __HIP_ARCH_HAS_SURFACE_FUNCS__: u32 = 0;
pub const __HIP_ARCH_HAS_3DGRID__: u32 = 0;
pub const __HIP_ARCH_HAS_DYNAMIC_PARALLEL__: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const GENERIC_GRID_LAUNCH: u32 = 1;
pub const __HIP_ROCclr__: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const HIP_TRSA_OVERRIDE_FORMAT: u32 = 1;
pub const HIP_TRSF_READ_AS_INTEGER: u32 = 1;
pub const HIP_TRSF_NORMALIZED_COORDINATES: u32 = 2;
pub const HIP_TRSF_SRGB: u32 = 16;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const hipTextureType1D: u32 = 1;
pub const hipTextureType2D: u32 = 2;
pub const hipTextureType3D: u32 = 3;
pub const hipTextureTypeCubemap: u32 = 12;
pub const hipTextureType1DLayered: u32 = 241;
pub const hipTextureType2DLayered: u32 = 242;
pub const hipTextureTypeCubemapLayered: u32 = 252;
pub const HIP_IMAGE_OBJECT_SIZE_DWORD: u32 = 12;
pub const HIP_SAMPLER_OBJECT_SIZE_DWORD: u32 = 8;
pub const HIP_SAMPLER_OBJECT_OFFSET_DWORD: u32 = 12;
pub const HIP_TEXTURE_OBJECT_SIZE_DWORD: u32 = 20;
pub const DEPRECATED_MSG : & 'static [ u8 ; 205usize ] = b"This API is marked as deprecated and may not be supported in future releases. For more details please refer https://github.com/ROCm-Developer-Tools/HIP/blob/master/docs/markdown/hip_deprecated_api_list.md\0" ;
pub const hipIpcMemLazyEnablePeerAccess: u32 = 0;
pub const HIP_IPC_HANDLE_SIZE: u32 = 64;
pub const hipStreamDefault: u32 = 0;
pub const hipStreamNonBlocking: u32 = 1;
pub const hipEventDefault: u32 = 0;
pub const hipEventBlockingSync: u32 = 1;
pub const hipEventDisableTiming: u32 = 2;
pub const hipEventInterprocess: u32 = 4;
pub const hipEventReleaseToDevice: u32 = 1073741824;
pub const hipEventReleaseToSystem: u32 = 2147483648;
pub const hipHostMallocDefault: u32 = 0;
pub const hipHostMallocPortable: u32 = 1;
pub const hipHostMallocMapped: u32 = 2;
pub const hipHostMallocWriteCombined: u32 = 4;
pub const hipHostMallocCoherent: u32 = 1073741824;
pub const hipHostMallocNonCoherent: u32 = 2147483648;
pub const hipMemAttachGlobal: u32 = 0;
pub const hipMemAttachHost: u32 = 1;
pub const hipDeviceMallocDefault: u32 = 0;
pub const hipDeviceMallocFinegrained: u32 = 1;
pub const hipHostRegisterDefault: u32 = 0;
pub const hipHostRegisterPortable: u32 = 1;
pub const hipHostRegisterMapped: u32 = 2;
pub const hipHostRegisterIoMemory: u32 = 4;
pub const hipExtHostRegisterCoarseGrained: u32 = 8;
pub const hipDeviceScheduleAuto: u32 = 0;
pub const hipDeviceScheduleSpin: u32 = 1;
pub const hipDeviceScheduleYield: u32 = 2;
pub const hipDeviceScheduleBlockingSync: u32 = 4;
pub const hipDeviceScheduleMask: u32 = 7;
pub const hipDeviceMapHost: u32 = 8;
pub const hipDeviceLmemResizeToMax: u32 = 22;
pub const hipArrayDefault: u32 = 0;
pub const hipArrayLayered: u32 = 1;
pub const hipArraySurfaceLoadStore: u32 = 2;
pub const hipArrayCubemap: u32 = 4;
pub const hipArrayTextureGather: u32 = 8;
pub const hipOccupancyDefault: u32 = 0;
pub const hipCooperativeLaunchMultiDeviceNoPreSync: u32 = 1;
pub const hipCooperativeLaunchMultiDeviceNoPostSync: u32 = 2;
pub const USE_PEER_NON_UNIFIED: u32 = 1;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::libc::c_void,
        __src: *const ::libc::c_void,
        __c: ::libc::c_int,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::libc::c_void,
        __c: ::libc::c_int,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::libc::c_void,
        __s2: *const ::libc::c_void,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::libc::c_void,
        __c: ::libc::c_int,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::libc::c_ushort,
    pub __ctype_tolower: *const ::libc::c_int,
    pub __ctype_toupper: *const ::libc::c_int,
    pub __names: [*const ::libc::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __l: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::libc::c_char, __n: ::libc::c_ulong) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::libc::c_char, __reject: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::libc::c_char, __accept: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::libc::c_char,
        __accept: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::libc::c_char,
        __needle: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::libc::c_char, __delim: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
        __save_ptr: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
        __save_ptr: *mut *mut ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::libc::c_char) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::libc::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::libc::c_int,
        __buf: *mut ::libc::c_char,
        __buflen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::libc::c_int, __l: locale_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::libc::c_void,
        __s2: *const ::libc::c_void,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::libc::c_void, __dest: *mut ::libc::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::libc::c_void, __n: ::libc::c_ulong);
}
extern "C" {
    pub fn index(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::libc::c_char, __c: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ffs(__i: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::libc::c_longlong) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::libc::c_char, __s2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __loc: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::libc::c_char,
        __s2: *const ::libc::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::libc::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::libc::c_char,
        __delim: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::libc::c_char, __src: *const ::libc::c_char)
        -> *mut ::libc::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::libc::c_char,
        __src: *const ::libc::c_char,
        __n: ::libc::c_ulong,
    ) -> *mut ::libc::c_char;
}
pub const HIP_SUCCESS: _bindgen_ty_1 = 0;
pub const HIP_ERROR_INVALID_VALUE: _bindgen_ty_1 = 1;
pub const HIP_ERROR_NOT_INITIALIZED: _bindgen_ty_1 = 2;
pub const HIP_ERROR_LAUNCH_OUT_OF_RESOURCES: _bindgen_ty_1 = 3;
pub type _bindgen_ty_1 = u32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct hipDeviceArch_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_hipDeviceArch_t() {
    assert_eq!(
        ::std::mem::size_of::<hipDeviceArch_t>(),
        4usize,
        concat!("Size of: ", stringify!(hipDeviceArch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipDeviceArch_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hipDeviceArch_t))
    );
}
impl hipDeviceArch_t {
    #[inline]
    pub fn hasGlobalInt32Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt32Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalFloatAtomicExch(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalFloatAtomicExch(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt32Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt32Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedFloatAtomicExch(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedFloatAtomicExch(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFloatAtomicAdd(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFloatAtomicAdd(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasGlobalInt64Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasGlobalInt64Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSharedInt64Atomics(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSharedInt64Atomics(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDoubles(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDoubles(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpVote(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpVote(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpBallot(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpBallot(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasWarpShuffle(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasWarpShuffle(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasFunnelShift(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasFunnelShift(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasThreadFenceSystem(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasThreadFenceSystem(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSyncThreadsExt(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSyncThreadsExt(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasSurfaceFuncs(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasSurfaceFuncs(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has3dGrid(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has3dGrid(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasDynamicParallelism(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasDynamicParallelism(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hasGlobalInt32Atomics: ::libc::c_uint,
        hasGlobalFloatAtomicExch: ::libc::c_uint,
        hasSharedInt32Atomics: ::libc::c_uint,
        hasSharedFloatAtomicExch: ::libc::c_uint,
        hasFloatAtomicAdd: ::libc::c_uint,
        hasGlobalInt64Atomics: ::libc::c_uint,
        hasSharedInt64Atomics: ::libc::c_uint,
        hasDoubles: ::libc::c_uint,
        hasWarpVote: ::libc::c_uint,
        hasWarpBallot: ::libc::c_uint,
        hasWarpShuffle: ::libc::c_uint,
        hasFunnelShift: ::libc::c_uint,
        hasThreadFenceSystem: ::libc::c_uint,
        hasSyncThreadsExt: ::libc::c_uint,
        hasSurfaceFuncs: ::libc::c_uint,
        has3dGrid: ::libc::c_uint,
        hasDynamicParallelism: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hasGlobalInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt32Atomics) };
            hasGlobalInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hasGlobalFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasGlobalFloatAtomicExch) };
            hasGlobalFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hasSharedInt32Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt32Atomics) };
            hasSharedInt32Atomics as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hasSharedFloatAtomicExch: u32 =
                unsafe { ::std::mem::transmute(hasSharedFloatAtomicExch) };
            hasSharedFloatAtomicExch as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hasFloatAtomicAdd: u32 = unsafe { ::std::mem::transmute(hasFloatAtomicAdd) };
            hasFloatAtomicAdd as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let hasGlobalInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasGlobalInt64Atomics) };
            hasGlobalInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasSharedInt64Atomics: u32 =
                unsafe { ::std::mem::transmute(hasSharedInt64Atomics) };
            hasSharedInt64Atomics as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let hasDoubles: u32 = unsafe { ::std::mem::transmute(hasDoubles) };
            hasDoubles as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let hasWarpVote: u32 = unsafe { ::std::mem::transmute(hasWarpVote) };
            hasWarpVote as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let hasWarpBallot: u32 = unsafe { ::std::mem::transmute(hasWarpBallot) };
            hasWarpBallot as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let hasWarpShuffle: u32 = unsafe { ::std::mem::transmute(hasWarpShuffle) };
            hasWarpShuffle as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let hasFunnelShift: u32 = unsafe { ::std::mem::transmute(hasFunnelShift) };
            hasFunnelShift as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hasThreadFenceSystem: u32 = unsafe { ::std::mem::transmute(hasThreadFenceSystem) };
            hasThreadFenceSystem as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hasSyncThreadsExt: u32 = unsafe { ::std::mem::transmute(hasSyncThreadsExt) };
            hasSyncThreadsExt as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let hasSurfaceFuncs: u32 = unsafe { ::std::mem::transmute(hasSurfaceFuncs) };
            hasSurfaceFuncs as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let has3dGrid: u32 = unsafe { ::std::mem::transmute(has3dGrid) };
            has3dGrid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let hasDynamicParallelism: u32 =
                unsafe { ::std::mem::transmute(hasDynamicParallelism) };
            hasDynamicParallelism as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " hipDeviceProp"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipDeviceProp_t {
    #[doc = "< Device name."]
    pub name: [::libc::c_char; 256usize],
    #[doc = "< Size of global memory region (in bytes)."]
    pub totalGlobalMem: usize,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub sharedMemPerBlock: usize,
    #[doc = "< Registers per block."]
    pub regsPerBlock: ::libc::c_int,
    #[doc = "< Warp size."]
    pub warpSize: ::libc::c_int,
    #[doc = "< Max work items per work group or workgroup max size."]
    pub maxThreadsPerBlock: ::libc::c_int,
    #[doc = "< Max number of threads in each dimension (XYZ) of a block."]
    pub maxThreadsDim: [::libc::c_int; 3usize],
    #[doc = "< Max grid dimensions (XYZ)."]
    pub maxGridSize: [::libc::c_int; 3usize],
    #[doc = "< Max clock frequency of the multiProcessors in khz."]
    pub clockRate: ::libc::c_int,
    #[doc = "< Max global memory clock frequency in khz."]
    pub memoryClockRate: ::libc::c_int,
    #[doc = "< Global memory bus width in bits."]
    pub memoryBusWidth: ::libc::c_int,
    #[doc = "< Size of shared memory region (in bytes)."]
    pub totalConstMem: usize,
    #[doc = "< Major compute capability.  On HCC, this is an approximation and features may"]
    #[doc = "< differ from CUDA CC.  See the arch feature flags for portable ways to query"]
    #[doc = "< feature caps."]
    pub major: ::libc::c_int,
    #[doc = "< Minor compute capability.  On HCC, this is an approximation and features may"]
    #[doc = "< differ from CUDA CC.  See the arch feature flags for portable ways to query"]
    #[doc = "< feature caps."]
    pub minor: ::libc::c_int,
    #[doc = "< Number of multi-processors (compute units)."]
    pub multiProcessorCount: ::libc::c_int,
    #[doc = "< L2 cache size."]
    pub l2CacheSize: ::libc::c_int,
    #[doc = "< Maximum resident threads per multi-processor."]
    pub maxThreadsPerMultiProcessor: ::libc::c_int,
    #[doc = "< Compute mode."]
    pub computeMode: ::libc::c_int,
    #[doc = "< Frequency in khz of the timer used by the device-side \"clock*\""]
    #[doc = "< instructions.  New for HIP."]
    pub clockInstructionRate: ::libc::c_int,
    #[doc = "< Architectural feature flags.  New for HIP."]
    pub arch: hipDeviceArch_t,
    #[doc = "< Device can possibly execute multiple kernels concurrently."]
    pub concurrentKernels: ::libc::c_int,
    #[doc = "< PCI Domain ID"]
    pub pciDomainID: ::libc::c_int,
    #[doc = "< PCI Bus ID."]
    pub pciBusID: ::libc::c_int,
    #[doc = "< PCI Device ID."]
    pub pciDeviceID: ::libc::c_int,
    #[doc = "< Maximum Shared Memory Per Multiprocessor."]
    pub maxSharedMemoryPerMultiProcessor: usize,
    #[doc = "< 1 if device is on a multi-GPU board, 0 if not."]
    pub isMultiGpuBoard: ::libc::c_int,
    #[doc = "< Check whether HIP can map host memory"]
    pub canMapHostMemory: ::libc::c_int,
    #[doc = "< AMD GCN Arch Value. Eg: 803, 701"]
    pub gcnArch: ::libc::c_int,
    #[doc = "< APU vs dGPU"]
    pub integrated: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch"]
    pub cooperativeLaunch: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple devices"]
    pub cooperativeMultiDeviceLaunch: ::libc::c_int,
    #[doc = "< Maximum number of elements in 1D images"]
    pub maxTexture1D: ::libc::c_int,
    #[doc = "< Maximum dimensions (width, height) of 2D images, in image elements"]
    pub maxTexture2D: [::libc::c_int; 2usize],
    #[doc = "< Maximum dimensions (width, height, depth) of 3D images, in image elements"]
    pub maxTexture3D: [::libc::c_int; 3usize],
    #[doc = "< Addres of HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    pub hdpMemFlushCntl: *mut ::libc::c_uint,
    #[doc = "< Addres of HDP_REG_COHERENCY_FLUSH_CNTL register"]
    pub hdpRegFlushCntl: *mut ::libc::c_uint,
    #[doc = "<Maximum pitch in bytes allowed by memory copies"]
    pub memPitch: usize,
    #[doc = "<Alignment requirement for textures"]
    pub textureAlignment: usize,
    #[doc = "<Pitch alignment requirement for texture references bound to pitched memory"]
    pub texturePitchAlignment: usize,
    #[doc = "<Run time limit for kernels executed on the device"]
    pub kernelExecTimeoutEnabled: ::libc::c_int,
    #[doc = "<Device has ECC support enabled"]
    pub ECCEnabled: ::libc::c_int,
    #[doc = "< 1:If device is Tesla device using TCC driver, else 0"]
    pub tccDriver: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedFunc: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedGridDim: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedBlockDim: ::libc::c_int,
    #[doc = "< HIP device supports cooperative launch on multiple"]
    pub cooperativeMultiDeviceUnmatchedSharedMem: ::libc::c_int,
    #[doc = "< 1: if it is a large PCI bar device, else 0"]
    pub isLargeBar: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_hipDeviceProp_t() {
    assert_eq!(
        ::std::mem::size_of::<hipDeviceProp_t>(),
        504usize,
        concat!("Size of: ", stringify!(hipDeviceProp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipDeviceProp_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipDeviceProp_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).totalGlobalMem as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(totalGlobalMem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).sharedMemPerBlock as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(sharedMemPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).regsPerBlock as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(regsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).warpSize as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(warpSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).maxThreadsPerBlock as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxThreadsDim as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxThreadsDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxGridSize as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxGridSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).clockRate as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(clockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).memoryClockRate as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(memoryClockRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).memoryBusWidth as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(memoryBusWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).totalConstMem as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(totalConstMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).major as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).minor as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).multiProcessorCount as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(multiProcessorCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).l2CacheSize as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(l2CacheSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).maxThreadsPerMultiProcessor as *const _
                as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxThreadsPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).computeMode as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(computeMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).clockInstructionRate as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(clockInstructionRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).arch as *const _ as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(arch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).concurrentKernels as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(concurrentKernels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).pciDomainID as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(pciDomainID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).pciBusID as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(pciBusID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).pciDeviceID as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(pciDeviceID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).maxSharedMemoryPerMultiProcessor as *const _
                as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxSharedMemoryPerMultiProcessor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).isMultiGpuBoard as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(isMultiGpuBoard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).canMapHostMemory as *const _ as usize
        },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(canMapHostMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).gcnArch as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(gcnArch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).integrated as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(integrated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeLaunch as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeLaunch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceLaunch as *const _
                as usize
        },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceLaunch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxTexture1D as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxTexture1D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxTexture2D as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxTexture2D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).maxTexture3D as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(maxTexture3D)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).hdpMemFlushCntl as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(hdpMemFlushCntl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).hdpRegFlushCntl as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(hdpRegFlushCntl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).memPitch as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(memPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).textureAlignment as *const _ as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(textureAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).texturePitchAlignment as *const _ as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(texturePitchAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).kernelExecTimeoutEnabled as *const _
                as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(kernelExecTimeoutEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).ECCEnabled as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(ECCEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).tccDriver as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(tccDriver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceUnmatchedFunc
                as *const _ as usize
        },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceUnmatchedGridDim
                as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedGridDim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceUnmatchedBlockDim
                as *const _ as usize
        },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedBlockDim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipDeviceProp_t>())).cooperativeMultiDeviceUnmatchedSharedMem
                as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(cooperativeMultiDeviceUnmatchedSharedMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipDeviceProp_t>())).isLargeBar as *const _ as usize },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(hipDeviceProp_t),
            "::",
            stringify!(isLargeBar)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Memory type (for pointer attributes)"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipMemoryType {
    #[doc = "< Memory is physically located on host"]
    hipMemoryTypeHost = 0,
    #[doc = "< Memory is physically located on device. (see deviceId for specific"]
    #[doc = "< device)"]
    hipMemoryTypeDevice = 1,
    #[doc = "< Array memory, physically located on device. (see deviceId for specific"]
    #[doc = "< device)"]
    hipMemoryTypeArray = 2,
    #[doc = "< Not used currently"]
    hipMemoryTypeUnified = 3,
}
#[doc = " Pointer attributes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPointerAttribute_t {
    pub memoryType: hipMemoryType,
    pub device: ::libc::c_int,
    pub devicePointer: *mut ::libc::c_void,
    pub hostPointer: *mut ::libc::c_void,
    pub isManaged: ::libc::c_int,
    pub allocationFlags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipPointerAttribute_t() {
    assert_eq!(
        ::std::mem::size_of::<hipPointerAttribute_t>(),
        32usize,
        concat!("Size of: ", stringify!(hipPointerAttribute_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPointerAttribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPointerAttribute_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipPointerAttribute_t>())).memoryType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(memoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPointerAttribute_t>())).device as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipPointerAttribute_t>())).devicePointer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(devicePointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipPointerAttribute_t>())).hostPointer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(hostPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPointerAttribute_t>())).isManaged as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(isManaged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipPointerAttribute_t>())).allocationFlags as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPointerAttribute_t),
            "::",
            stringify!(allocationFlags)
        )
    );
}
impl hipError_t {
    pub const hipErrorMemoryAllocation: hipError_t = hipError_t::hipErrorOutOfMemory;
}
impl hipError_t {
    pub const hipErrorInitializationError: hipError_t = hipError_t::hipErrorNotInitialized;
}
impl hipError_t {
    pub const hipErrorMapBufferObjectFailed: hipError_t = hipError_t::hipErrorMapFailed;
}
impl hipError_t {
    pub const hipErrorInvalidResourceHandle: hipError_t = hipError_t::hipErrorInvalidHandle;
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipError_t {
    #[doc = "< Successful completion."]
    hipSuccess = 0,
    #[doc = "< One or more of the parameters passed to the API call is NULL"]
    #[doc = "< or not in an acceptable range."]
    hipErrorInvalidValue = 1,
    hipErrorOutOfMemory = 2,
    hipErrorNotInitialized = 3,
    hipErrorDeinitialized = 4,
    hipErrorProfilerDisabled = 5,
    hipErrorProfilerNotInitialized = 6,
    hipErrorProfilerAlreadyStarted = 7,
    hipErrorProfilerAlreadyStopped = 8,
    hipErrorInvalidConfiguration = 9,
    hipErrorInvalidSymbol = 13,
    #[doc = "< Invalid Device Pointer"]
    hipErrorInvalidDevicePointer = 17,
    #[doc = "< Invalid memory copy direction"]
    hipErrorInvalidMemcpyDirection = 21,
    hipErrorInsufficientDriver = 35,
    hipErrorMissingConfiguration = 52,
    hipErrorPriorLaunchFailure = 53,
    hipErrorInvalidDeviceFunction = 98,
    #[doc = "< Call to hipGetDeviceCount returned 0 devices"]
    hipErrorNoDevice = 100,
    #[doc = "< DeviceID must be in range 0...#compute-devices."]
    hipErrorInvalidDevice = 101,
    hipErrorInvalidImage = 200,
    #[doc = "< Produced when input context is invalid."]
    hipErrorInvalidContext = 201,
    hipErrorContextAlreadyCurrent = 202,
    hipErrorMapFailed = 205,
    hipErrorUnmapFailed = 206,
    hipErrorArrayIsMapped = 207,
    hipErrorAlreadyMapped = 208,
    hipErrorNoBinaryForGpu = 209,
    hipErrorAlreadyAcquired = 210,
    hipErrorNotMapped = 211,
    hipErrorNotMappedAsArray = 212,
    hipErrorNotMappedAsPointer = 213,
    hipErrorECCNotCorrectable = 214,
    hipErrorUnsupportedLimit = 215,
    hipErrorContextAlreadyInUse = 216,
    hipErrorPeerAccessUnsupported = 217,
    #[doc = "< In CUDA DRV, it is CUDA_ERROR_INVALID_PTX"]
    hipErrorInvalidKernelFile = 218,
    hipErrorInvalidGraphicsContext = 219,
    hipErrorInvalidSource = 300,
    hipErrorFileNotFound = 301,
    hipErrorSharedObjectSymbolNotFound = 302,
    hipErrorSharedObjectInitFailed = 303,
    hipErrorOperatingSystem = 304,
    hipErrorInvalidHandle = 400,
    hipErrorNotFound = 500,
    #[doc = "< Indicates that asynchronous operations enqueued earlier are not"]
    #[doc = "< ready.  This is not actually an error, but is used to distinguish"]
    #[doc = "< from hipSuccess (which indicates completion).  APIs that return"]
    #[doc = "< this error include hipEventQuery and hipStreamQuery."]
    hipErrorNotReady = 600,
    hipErrorIllegalAddress = 700,
    #[doc = "< Out of resources error."]
    hipErrorLaunchOutOfResources = 701,
    hipErrorLaunchTimeOut = 702,
    hipErrorPeerAccessAlreadyEnabled = 704,
    hipErrorPeerAccessNotEnabled = 705,
    hipErrorSetOnActiveProcess = 708,
    #[doc = "< Produced when the kernel calls assert."]
    hipErrorAssert = 710,
    hipErrorHostMemoryAlreadyRegistered = 712,
    hipErrorHostMemoryNotRegistered = 713,
    hipErrorLaunchFailure = 719,
    hipErrorCooperativeLaunchTooLarge = 720,
    #[doc = "< Produced when the hip API is not supported/implemented"]
    hipErrorNotSupported = 801,
    hipErrorUnknown = 999,
    #[doc = "< HSA runtime memory call returned error.  Typically not seen"]
    #[doc = "< in production systems."]
    hipErrorRuntimeMemory = 1052,
    #[doc = "< HSA runtime call other than memory returned error.  Typically"]
    #[doc = "< not seen in production systems."]
    hipErrorRuntimeOther = 1053,
    #[doc = "< Marker that more error codes are needed."]
    hipErrorTbd = 1054,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipDeviceAttribute_t {
    #[doc = "< Maximum number of threads per block."]
    hipDeviceAttributeMaxThreadsPerBlock = 0,
    #[doc = "< Maximum x-dimension of a block."]
    hipDeviceAttributeMaxBlockDimX = 1,
    #[doc = "< Maximum y-dimension of a block."]
    hipDeviceAttributeMaxBlockDimY = 2,
    #[doc = "< Maximum z-dimension of a block."]
    hipDeviceAttributeMaxBlockDimZ = 3,
    #[doc = "< Maximum x-dimension of a grid."]
    hipDeviceAttributeMaxGridDimX = 4,
    #[doc = "< Maximum y-dimension of a grid."]
    hipDeviceAttributeMaxGridDimY = 5,
    #[doc = "< Maximum z-dimension of a grid."]
    hipDeviceAttributeMaxGridDimZ = 6,
    #[doc = "< Maximum shared memory available per block in"]
    #[doc = "< bytes."]
    hipDeviceAttributeMaxSharedMemoryPerBlock = 7,
    #[doc = "< Constant memory size in bytes."]
    hipDeviceAttributeTotalConstantMemory = 8,
    #[doc = "< Warp size in threads."]
    hipDeviceAttributeWarpSize = 9,
    #[doc = "< Maximum number of 32-bit registers available to a"]
    #[doc = "< thread block. This number is shared by all thread"]
    #[doc = "< blocks simultaneously resident on a"]
    #[doc = "< multiprocessor."]
    hipDeviceAttributeMaxRegistersPerBlock = 10,
    #[doc = "< Peak clock frequency in kilohertz."]
    hipDeviceAttributeClockRate = 11,
    #[doc = "< Peak memory clock frequency in kilohertz."]
    hipDeviceAttributeMemoryClockRate = 12,
    #[doc = "< Global memory bus width in bits."]
    hipDeviceAttributeMemoryBusWidth = 13,
    #[doc = "< Number of multiprocessors on the device."]
    hipDeviceAttributeMultiprocessorCount = 14,
    #[doc = "< Compute mode that device is currently in."]
    hipDeviceAttributeComputeMode = 15,
    #[doc = "< Size of L2 cache in bytes. 0 if the device doesn't have L2"]
    #[doc = "< cache."]
    hipDeviceAttributeL2CacheSize = 16,
    #[doc = "< Maximum resident threads per"]
    #[doc = "< multiprocessor."]
    hipDeviceAttributeMaxThreadsPerMultiProcessor = 17,
    #[doc = "< Major compute capability version number."]
    hipDeviceAttributeComputeCapabilityMajor = 18,
    #[doc = "< Minor compute capability version number."]
    hipDeviceAttributeComputeCapabilityMinor = 19,
    #[doc = "< Device can possibly execute multiple kernels"]
    #[doc = "< concurrently."]
    hipDeviceAttributeConcurrentKernels = 20,
    #[doc = "< PCI Bus ID."]
    hipDeviceAttributePciBusId = 21,
    #[doc = "< PCI Device ID."]
    hipDeviceAttributePciDeviceId = 22,
    #[doc = "< Maximum Shared Memory Per"]
    #[doc = "< Multiprocessor."]
    hipDeviceAttributeMaxSharedMemoryPerMultiprocessor = 23,
    #[doc = "< Multiple GPU devices."]
    hipDeviceAttributeIsMultiGpuBoard = 24,
    #[doc = "< iGPU"]
    hipDeviceAttributeIntegrated = 25,
    #[doc = "< Support cooperative launch"]
    hipDeviceAttributeCooperativeLaunch = 26,
    #[doc = "< Support cooperative launch on multiple devices"]
    hipDeviceAttributeCooperativeMultiDeviceLaunch = 27,
    #[doc = "< Maximum number of elements in 1D images"]
    hipDeviceAttributeMaxTexture1DWidth = 28,
    #[doc = "< Maximum dimension width of 2D images in image elements"]
    hipDeviceAttributeMaxTexture2DWidth = 29,
    #[doc = "< Maximum dimension height of 2D images in image elements"]
    hipDeviceAttributeMaxTexture2DHeight = 30,
    #[doc = "< Maximum dimension width of 3D images in image elements"]
    hipDeviceAttributeMaxTexture3DWidth = 31,
    #[doc = "< Maximum dimensions height of 3D images in image elements"]
    hipDeviceAttributeMaxTexture3DHeight = 32,
    #[doc = "< Maximum dimensions depth of 3D images in image elements"]
    hipDeviceAttributeMaxTexture3DDepth = 33,
    #[doc = "< Address of the HDP_MEM_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpMemFlushCntl = 34,
    #[doc = "< Address of the HDP_REG_COHERENCY_FLUSH_CNTL register"]
    hipDeviceAttributeHdpRegFlushCntl = 35,
    #[doc = "< Maximum pitch in bytes allowed by memory copies"]
    hipDeviceAttributeMaxPitch = 36,
    #[doc = "<Alignment requirement for textures"]
    hipDeviceAttributeTextureAlignment = 37,
    #[doc = "<Pitch alignment requirement for 2D texture references bound to pitched memory;"]
    hipDeviceAttributeTexturePitchAlignment = 38,
    #[doc = "<Run time limit for kernels executed on the device"]
    hipDeviceAttributeKernelExecTimeout = 39,
    #[doc = "<Device can map host memory into device address space"]
    hipDeviceAttributeCanMapHostMemory = 40,
    #[doc = "<Device has ECC support enabled"]
    hipDeviceAttributeEccEnabled = 41,
    #[doc = "< Supports cooperative launch on multiple"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedFunc = 42,
    #[doc = "< Supports cooperative launch on multiple"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedGridDim = 43,
    #[doc = "< Supports cooperative launch on multiple"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedBlockDim = 44,
    #[doc = "< Supports cooperative launch on multiple"]
    hipDeviceAttributeCooperativeMultiDeviceUnmatchedSharedMem = 45,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipComputeMode {
    hipComputeModeDefault = 0,
    hipComputeModeExclusive = 1,
    hipComputeModeProhibited = 2,
    hipComputeModeExclusiveProcess = 3,
}
pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __intmax_t = ::libc::c_long;
pub type __uintmax_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
pub type __sig_atomic_t = ::libc::c_int;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type hipDeviceptr_t = *mut ::libc::c_void;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipChannelFormatKind {
    hipChannelFormatKindSigned = 0,
    hipChannelFormatKindUnsigned = 1,
    hipChannelFormatKindFloat = 2,
    hipChannelFormatKindNone = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipChannelFormatDesc {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
    pub f: hipChannelFormatKind,
}
#[test]
fn bindgen_test_layout_hipChannelFormatDesc() {
    assert_eq!(
        ::std::mem::size_of::<hipChannelFormatDesc>(),
        20usize,
        concat!("Size of: ", stringify!(hipChannelFormatDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipChannelFormatDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(hipChannelFormatDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipChannelFormatDesc>())).f as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipChannelFormatDesc),
            "::",
            stringify!(f)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipArray_Format {
    HIP_AD_FORMAT_UNSIGNED_INT8 = 1,
    HIP_AD_FORMAT_UNSIGNED_INT16 = 2,
    HIP_AD_FORMAT_UNSIGNED_INT32 = 3,
    HIP_AD_FORMAT_SIGNED_INT8 = 8,
    HIP_AD_FORMAT_SIGNED_INT16 = 9,
    HIP_AD_FORMAT_SIGNED_INT32 = 10,
    HIP_AD_FORMAT_HALF = 16,
    HIP_AD_FORMAT_FLOAT = 32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_HIP_ARRAY_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<HIP_ARRAY_DESCRIPTOR>(),
        24usize,
        concat!("Size of: ", stringify!(HIP_ARRAY_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_ARRAY_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_ARRAY_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY_DESCRIPTOR>())).Width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY_DESCRIPTOR>())).Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY_DESCRIPTOR>())).Format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_ARRAY_DESCRIPTOR>())).NumChannels as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY_DESCRIPTOR),
            "::",
            stringify!(NumChannels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_ARRAY3D_DESCRIPTOR {
    pub Width: usize,
    pub Height: usize,
    pub Depth: usize,
    pub Format: hipArray_Format,
    pub NumChannels: ::libc::c_uint,
    pub Flags: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_HIP_ARRAY3D_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<HIP_ARRAY3D_DESCRIPTOR>(),
        40usize,
        concat!("Size of: ", stringify!(HIP_ARRAY3D_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_ARRAY3D_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_ARRAY3D_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).NumChannels as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_ARRAY3D_DESCRIPTOR>())).Flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_ARRAY3D_DESCRIPTOR),
            "::",
            stringify!(Flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipArray {
    pub data: *mut ::libc::c_void,
    pub desc: hipChannelFormatDesc,
    pub type_: ::libc::c_uint,
    pub width: ::libc::c_uint,
    pub height: ::libc::c_uint,
    pub depth: ::libc::c_uint,
    pub Format: hipArray_Format,
    pub NumChannels: ::libc::c_uint,
    pub isDrv: bool,
    pub textureType: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipArray() {
    assert_eq!(
        ::std::mem::size_of::<hipArray>(),
        64usize,
        concat!("Size of: ", stringify!(hipArray))
    );
    assert_eq!(
        ::std::mem::align_of::<hipArray>(),
        8usize,
        concat!("Alignment of ", stringify!(hipArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).type_ as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).width as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).height as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).depth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).Format as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(Format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).NumChannels as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(NumChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).isDrv as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(isDrv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipArray>())).textureType as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hipArray),
            "::",
            stringify!(textureType)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hip_Memcpy2D {
    pub srcXInBytes: usize,
    pub srcY: usize,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::libc::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: *mut hipArray,
    pub srcPitch: usize,
    pub dstXInBytes: usize,
    pub dstY: usize,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::libc::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: *mut hipArray,
    pub dstPitch: usize,
    pub WidthInBytes: usize,
    pub Height: usize,
}
#[test]
fn bindgen_test_layout_hip_Memcpy2D() {
    assert_eq!(
        ::std::mem::size_of::<hip_Memcpy2D>(),
        128usize,
        concat!("Size of: ", stringify!(hip_Memcpy2D))
    );
    assert_eq!(
        ::std::mem::align_of::<hip_Memcpy2D>(),
        8usize,
        concat!("Alignment of ", stringify!(hip_Memcpy2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcY as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcMemoryType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcHost as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcDevice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcArray as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).srcPitch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstXInBytes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstY as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstMemoryType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstHost as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstDevice as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstArray as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).dstPitch as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).WidthInBytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hip_Memcpy2D>())).Height as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_Memcpy2D),
            "::",
            stringify!(Height)
        )
    );
}
pub type hipArray_t = *mut hipArray;
pub type hipArray_const_t = *const hipArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMipmappedArray {
    pub data: *mut ::libc::c_void,
    pub desc: hipChannelFormatDesc,
    pub width: ::libc::c_uint,
    pub height: ::libc::c_uint,
    pub depth: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipMipmappedArray() {
    assert_eq!(
        ::std::mem::size_of::<hipMipmappedArray>(),
        40usize,
        concat!("Size of: ", stringify!(hipMipmappedArray))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMipmappedArray>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMipmappedArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).width as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).height as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMipmappedArray>())).depth as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMipmappedArray),
            "::",
            stringify!(depth)
        )
    );
}
pub type hipMipmappedArray_t = *mut hipMipmappedArray;
pub type hipMipmappedArray_const_t = *const hipMipmappedArray;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip resource types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipResourceType {
    hipResourceTypeArray = 0,
    hipResourceTypeMipmappedArray = 1,
    hipResourceTypeLinear = 2,
    hipResourceTypePitch2D = 3,
}
#[doc = "< Array resoure"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_ARRAY: HIPresourcetype_enum = 0;
#[doc = "< Mipmapped array resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_MIPMAPPED_ARRAY: HIPresourcetype_enum = 1;
#[doc = "< Linear resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_LINEAR: HIPresourcetype_enum = 2;
#[doc = "< Pitch 2D resource"]
pub const HIPresourcetype_enum_HIP_RESOURCE_TYPE_PITCH2D: HIPresourcetype_enum = 3;
pub type HIPresourcetype_enum = u32;
pub use self::HIPresourcetype_enum as HIPresourcetype;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_WRAP: HIPaddress_mode_enum = 0;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_CLAMP: HIPaddress_mode_enum = 1;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_MIRROR: HIPaddress_mode_enum = 2;
pub const HIPaddress_mode_enum_HIP_TR_ADDRESS_MODE_BORDER: HIPaddress_mode_enum = 3;
#[doc = " hip address modes"]
pub type HIPaddress_mode_enum = u32;
#[doc = " hip address modes"]
pub use self::HIPaddress_mode_enum as HIPaddress_mode;
pub const HIPfilter_mode_enum_HIP_TR_FILTER_MODE_POINT: HIPfilter_mode_enum = 0;
pub const HIPfilter_mode_enum_HIP_TR_FILTER_MODE_LINEAR: HIPfilter_mode_enum = 1;
#[doc = " hip filter modes"]
pub type HIPfilter_mode_enum = u32;
#[doc = " hip filter modes"]
pub use self::HIPfilter_mode_enum as HIPfilter_mode;
#[doc = " Texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_TEXTURE_DESC_st {
    #[doc = "< Address modes"]
    pub addressMode: [HIPaddress_mode; 3usize],
    #[doc = "< Filter mode"]
    pub filterMode: HIPfilter_mode,
    #[doc = "< Flags"]
    pub flags: ::libc::c_uint,
    #[doc = "< Maximum anisotropy ratio"]
    pub maxAnisotropy: ::libc::c_uint,
    #[doc = "< Mipmap filter mode"]
    pub mipmapFilterMode: HIPfilter_mode,
    #[doc = "< Mipmap level bias"]
    pub mipmapLevelBias: f32,
    #[doc = "< Mipmap minimum level clamp"]
    pub minMipmapLevelClamp: f32,
    #[doc = "< Mipmap maximum level clamp"]
    pub maxMipmapLevelClamp: f32,
    #[doc = "< Border Color"]
    pub borderColor: [f32; 4usize],
    pub reserved: [::libc::c_int; 12usize],
}
#[test]
fn bindgen_test_layout_HIP_TEXTURE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<HIP_TEXTURE_DESC_st>(),
        104usize,
        concat!("Size of: ", stringify!(HIP_TEXTURE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_TEXTURE_DESC_st>(),
        4usize,
        concat!("Alignment of ", stringify!(HIP_TEXTURE_DESC_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).addressMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).filterMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).maxAnisotropy as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).mipmapFilterMode as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).mipmapLevelBias as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).minMipmapLevelClamp as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).maxMipmapLevelClamp as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).borderColor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_TEXTURE_DESC_st>())).reserved as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_TEXTURE_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Texture descriptor"]
pub type HIP_TEXTURE_DESC = HIP_TEXTURE_DESC_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture resource view formats"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipResourceViewFormat {
    hipResViewFormatNone = 0,
    hipResViewFormatUnsignedChar1 = 1,
    hipResViewFormatUnsignedChar2 = 2,
    hipResViewFormatUnsignedChar4 = 3,
    hipResViewFormatSignedChar1 = 4,
    hipResViewFormatSignedChar2 = 5,
    hipResViewFormatSignedChar4 = 6,
    hipResViewFormatUnsignedShort1 = 7,
    hipResViewFormatUnsignedShort2 = 8,
    hipResViewFormatUnsignedShort4 = 9,
    hipResViewFormatSignedShort1 = 10,
    hipResViewFormatSignedShort2 = 11,
    hipResViewFormatSignedShort4 = 12,
    hipResViewFormatUnsignedInt1 = 13,
    hipResViewFormatUnsignedInt2 = 14,
    hipResViewFormatUnsignedInt4 = 15,
    hipResViewFormatSignedInt1 = 16,
    hipResViewFormatSignedInt2 = 17,
    hipResViewFormatSignedInt4 = 18,
    hipResViewFormatHalf1 = 19,
    hipResViewFormatHalf2 = 20,
    hipResViewFormatHalf4 = 21,
    hipResViewFormatFloat1 = 22,
    hipResViewFormatFloat2 = 23,
    hipResViewFormatFloat4 = 24,
    hipResViewFormatUnsignedBlockCompressed1 = 25,
    hipResViewFormatUnsignedBlockCompressed2 = 26,
    hipResViewFormatUnsignedBlockCompressed3 = 27,
    hipResViewFormatUnsignedBlockCompressed4 = 28,
    hipResViewFormatSignedBlockCompressed4 = 29,
    hipResViewFormatUnsignedBlockCompressed5 = 30,
    hipResViewFormatSignedBlockCompressed5 = 31,
    hipResViewFormatUnsignedBlockCompressed6H = 32,
    hipResViewFormatSignedBlockCompressed6H = 33,
    hipResViewFormatUnsignedBlockCompressed7 = 34,
}
#[doc = "< No resource view format (use underlying resource format)"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_NONE: HIPresourceViewFormat_enum = 0;
#[doc = "< 1 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X8: HIPresourceViewFormat_enum = 1;
#[doc = "< 2 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X8: HIPresourceViewFormat_enum = 2;
#[doc = "< 4 channel unsigned 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X8: HIPresourceViewFormat_enum = 3;
#[doc = "< 1 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X8: HIPresourceViewFormat_enum = 4;
#[doc = "< 2 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X8: HIPresourceViewFormat_enum = 5;
#[doc = "< 4 channel signed 8-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X8: HIPresourceViewFormat_enum = 6;
#[doc = "< 1 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X16: HIPresourceViewFormat_enum = 7;
#[doc = "< 2 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X16: HIPresourceViewFormat_enum = 8;
#[doc = "< 4 channel unsigned 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X16: HIPresourceViewFormat_enum = 9;
#[doc = "< 1 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X16: HIPresourceViewFormat_enum = 10;
#[doc = "< 2 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X16: HIPresourceViewFormat_enum = 11;
#[doc = "< 4 channel signed 16-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X16: HIPresourceViewFormat_enum = 12;
#[doc = "< 1 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_1X32: HIPresourceViewFormat_enum = 13;
#[doc = "< 2 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_2X32: HIPresourceViewFormat_enum = 14;
#[doc = "< 4 channel unsigned 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UINT_4X32: HIPresourceViewFormat_enum = 15;
#[doc = "< 1 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_1X32: HIPresourceViewFormat_enum = 16;
#[doc = "< 2 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_2X32: HIPresourceViewFormat_enum = 17;
#[doc = "< 4 channel signed 32-bit integers"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SINT_4X32: HIPresourceViewFormat_enum = 18;
#[doc = "< 1 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_1X16: HIPresourceViewFormat_enum =
    19;
#[doc = "< 2 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_2X16: HIPresourceViewFormat_enum =
    20;
#[doc = "< 4 channel 16-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_4X16: HIPresourceViewFormat_enum =
    21;
#[doc = "< 1 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_1X32: HIPresourceViewFormat_enum =
    22;
#[doc = "< 2 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_2X32: HIPresourceViewFormat_enum =
    23;
#[doc = "< 4 channel 32-bit floating point"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_FLOAT_4X32: HIPresourceViewFormat_enum =
    24;
#[doc = "< Block compressed 1"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC1: HIPresourceViewFormat_enum =
    25;
#[doc = "< Block compressed 2"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC2: HIPresourceViewFormat_enum =
    26;
#[doc = "< Block compressed 3"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC3: HIPresourceViewFormat_enum =
    27;
#[doc = "< Block compressed 4 unsigned"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC4: HIPresourceViewFormat_enum =
    28;
#[doc = "< Block compressed 4 signed"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC4: HIPresourceViewFormat_enum =
    29;
#[doc = "< Block compressed 5 unsigned"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC5: HIPresourceViewFormat_enum =
    30;
#[doc = "< Block compressed 5 signed"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC5: HIPresourceViewFormat_enum =
    31;
#[doc = "< Block compressed 6 unsigned half-float"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC6H: HIPresourceViewFormat_enum =
    32;
#[doc = "< Block compressed 6 signed half-float"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_SIGNED_BC6H: HIPresourceViewFormat_enum =
    33;
#[doc = "< Block compressed 7"]
pub const HIPresourceViewFormat_enum_HIP_RES_VIEW_FORMAT_UNSIGNED_BC7: HIPresourceViewFormat_enum =
    34;
pub type HIPresourceViewFormat_enum = u32;
pub use self::HIPresourceViewFormat_enum as HIPresourceViewFormat;
#[doc = " HIP resource descriptor"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipResourceDesc {
    pub resType: hipResourceType,
    pub res: hipResourceDesc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hipResourceDesc__bindgen_ty_1 {
    pub array: hipResourceDesc__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: hipResourceDesc__bindgen_ty_1__bindgen_ty_2,
    pub linear: hipResourceDesc__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: hipResourceDesc__bindgen_ty_1__bindgen_ty_4,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_1 {
    pub array: hipArray_t,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_1>())).array
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_2 {
    pub mipmap: hipMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_2>())).mipmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mipmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_3 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: hipChannelFormatDesc,
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>())).desc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_3>())).sizeInBytes
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceDesc__bindgen_ty_1__bindgen_ty_4 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: hipChannelFormatDesc,
    pub width: usize,
    pub height: usize,
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).desc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1__bindgen_ty_4>())).pitchInBytes
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[test]
fn bindgen_test_layout_hipResourceDesc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(hipResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceDesc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1>())).array as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1>())).mipmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1>())).linear as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceDesc__bindgen_ty_1>())).pitch2D as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
}
#[test]
fn bindgen_test_layout_hipResourceDesc() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceDesc>(),
        64usize,
        concat!("Size of: ", stringify!(hipResourceDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceDesc>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceDesc>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceDesc),
            "::",
            stringify!(res)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st {
    #[doc = "< Resource type"]
    pub resType: HIPresourcetype,
    pub res: HIP_RESOURCE_DESC_st__bindgen_ty_1,
    #[doc = "< Flags (must be zero)"]
    pub flags: ::libc::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HIP_RESOURCE_DESC_st__bindgen_ty_1 {
    pub array: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1,
    pub mipmap: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2,
    pub linear: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3,
    pub pitch2D: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4,
    pub reserved: HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< HIP array"]
    pub hArray: hipArray_t,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1>())).hArray
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< HIP mipmapped array"]
    pub hMipmappedArray: hipMipmappedArray_t,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2>()))
                .hMipmappedArray as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(hMipmappedArray)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::libc::c_uint,
    #[doc = "< Size in bytes"]
    pub sizeInBytes: usize,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).numChannels
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3>())).sizeInBytes
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(sizeInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4 {
    #[doc = "< Device pointer"]
    pub devPtr: hipDeviceptr_t,
    #[doc = "< Array format"]
    pub format: hipArray_Format,
    #[doc = "< Channels per array element"]
    pub numChannels: ::libc::c_uint,
    #[doc = "< Width of the array in elements"]
    pub width: usize,
    #[doc = "< Height of the array in elements"]
    pub height: usize,
    #[doc = "< Pitch between two rows in bytes"]
    pub pitchInBytes: usize,
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).devPtr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(devPtr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).format
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).numChannels
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).width
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>())).height
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4>()))
                .pitchInBytes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(pitchInBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5 {
    pub reserved: [::libc::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5>())).reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).array as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).mipmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(mipmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).linear as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).pitch2D as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(pitch2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st__bindgen_ty_1>())).reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st__bindgen_ty_1),
            "::",
            stringify!(reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_DESC_st>(),
        144usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_RESOURCE_DESC_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st>())).resType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(resType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st>())).res as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(res)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_DESC_st>())).flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_DESC_st),
            "::",
            stringify!(flags)
        )
    );
}
pub type HIP_RESOURCE_DESC = HIP_RESOURCE_DESC_st;
#[doc = " hip resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipResourceViewDesc {
    pub format: hipResourceViewFormat,
    pub width: usize,
    pub height: usize,
    pub depth: usize,
    pub firstMipmapLevel: ::libc::c_uint,
    pub lastMipmapLevel: ::libc::c_uint,
    pub firstLayer: ::libc::c_uint,
    pub lastLayer: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_hipResourceViewDesc() {
    assert_eq!(
        ::std::mem::size_of::<hipResourceViewDesc>(),
        48usize,
        concat!("Size of: ", stringify!(hipResourceViewDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipResourceViewDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(hipResourceViewDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceViewDesc>())).firstMipmapLevel as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipResourceViewDesc>())).lastMipmapLevel as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).firstLayer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipResourceViewDesc>())).lastLayer as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipResourceViewDesc),
            "::",
            stringify!(lastLayer)
        )
    );
}
#[doc = " Resource view descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_RESOURCE_VIEW_DESC_st {
    #[doc = "< Resource view format"]
    pub format: HIPresourceViewFormat,
    #[doc = "< Width of the resource view"]
    pub width: usize,
    #[doc = "< Height of the resource view"]
    pub height: usize,
    #[doc = "< Depth of the resource view"]
    pub depth: usize,
    #[doc = "< First defined mipmap level"]
    pub firstMipmapLevel: ::libc::c_uint,
    #[doc = "< Last defined mipmap level"]
    pub lastMipmapLevel: ::libc::c_uint,
    #[doc = "< First layer index"]
    pub firstLayer: ::libc::c_uint,
    #[doc = "< Last layer index"]
    pub lastLayer: ::libc::c_uint,
    pub reserved: [::libc::c_uint; 16usize],
}
#[test]
fn bindgen_test_layout_HIP_RESOURCE_VIEW_DESC_st() {
    assert_eq!(
        ::std::mem::size_of::<HIP_RESOURCE_VIEW_DESC_st>(),
        112usize,
        concat!("Size of: ", stringify!(HIP_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_RESOURCE_VIEW_DESC_st>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_RESOURCE_VIEW_DESC_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).format as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).firstMipmapLevel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).lastMipmapLevel as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastMipmapLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).firstLayer as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(firstLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).lastLayer as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(lastLayer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HIP_RESOURCE_VIEW_DESC_st>())).reserved as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_RESOURCE_VIEW_DESC_st),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Resource view descriptor"]
pub type HIP_RESOURCE_VIEW_DESC = HIP_RESOURCE_VIEW_DESC_st;
#[repr(u32)]
#[non_exhaustive]
#[doc = " Memory copy types"]
#[doc = ""]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipMemcpyKind {
    #[doc = "< Host-to-Host Copy"]
    hipMemcpyHostToHost = 0,
    #[doc = "< Host-to-Device Copy"]
    hipMemcpyHostToDevice = 1,
    #[doc = "< Device-to-Host Copy"]
    hipMemcpyDeviceToHost = 2,
    #[doc = "< Device-to-Device Copy"]
    hipMemcpyDeviceToDevice = 3,
    hipMemcpyDefault = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPitchedPtr {
    pub ptr: *mut ::libc::c_void,
    pub pitch: usize,
    pub xsize: usize,
    pub ysize: usize,
}
#[test]
fn bindgen_test_layout_hipPitchedPtr() {
    assert_eq!(
        ::std::mem::size_of::<hipPitchedPtr>(),
        32usize,
        concat!("Size of: ", stringify!(hipPitchedPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPitchedPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPitchedPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPitchedPtr>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPitchedPtr>())).pitch as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPitchedPtr>())).xsize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPitchedPtr>())).ysize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipPitchedPtr),
            "::",
            stringify!(ysize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipExtent {
    pub width: usize,
    pub height: usize,
    pub depth: usize,
}
#[test]
fn bindgen_test_layout_hipExtent() {
    assert_eq!(
        ::std::mem::size_of::<hipExtent>(),
        24usize,
        concat!("Size of: ", stringify!(hipExtent))
    );
    assert_eq!(
        ::std::mem::align_of::<hipExtent>(),
        8usize,
        concat!("Alignment of ", stringify!(hipExtent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipExtent>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipExtent>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipExtent>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipExtent),
            "::",
            stringify!(depth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipPos {
    pub x: usize,
    pub y: usize,
    pub z: usize,
}
#[test]
fn bindgen_test_layout_hipPos() {
    assert_eq!(
        ::std::mem::size_of::<hipPos>(),
        24usize,
        concat!("Size of: ", stringify!(hipPos))
    );
    assert_eq!(
        ::std::mem::align_of::<hipPos>(),
        8usize,
        concat!("Alignment of ", stringify!(hipPos))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPos>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPos>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipPos>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(hipPos), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipMemcpy3DParms {
    pub srcArray: hipArray_t,
    pub srcPos: hipPos,
    pub srcPtr: hipPitchedPtr,
    pub dstArray: hipArray_t,
    pub dstPos: hipPos,
    pub dstPtr: hipPitchedPtr,
    pub extent: hipExtent,
    pub kind: hipMemcpyKind,
}
#[test]
fn bindgen_test_layout_hipMemcpy3DParms() {
    assert_eq!(
        ::std::mem::size_of::<hipMemcpy3DParms>(),
        160usize,
        concat!("Size of: ", stringify!(hipMemcpy3DParms))
    );
    assert_eq!(
        ::std::mem::align_of::<hipMemcpy3DParms>(),
        8usize,
        concat!("Alignment of ", stringify!(hipMemcpy3DParms))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).srcArray as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).srcPos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).srcPtr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(srcPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).dstArray as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).dstPos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstPos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).dstPtr as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(dstPtr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).extent as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(extent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipMemcpy3DParms>())).kind as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(hipMemcpy3DParms),
            "::",
            stringify!(kind)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HIP_MEMCPY3D {
    pub srcXInBytes: ::libc::c_uint,
    pub srcY: ::libc::c_uint,
    pub srcZ: ::libc::c_uint,
    pub srcLOD: ::libc::c_uint,
    pub srcMemoryType: hipMemoryType,
    pub srcHost: *const ::libc::c_void,
    pub srcDevice: hipDeviceptr_t,
    pub srcArray: hipArray_t,
    pub srcPitch: ::libc::c_uint,
    pub srcHeight: ::libc::c_uint,
    pub dstXInBytes: ::libc::c_uint,
    pub dstY: ::libc::c_uint,
    pub dstZ: ::libc::c_uint,
    pub dstLOD: ::libc::c_uint,
    pub dstMemoryType: hipMemoryType,
    pub dstHost: *mut ::libc::c_void,
    pub dstDevice: hipDeviceptr_t,
    pub dstArray: hipArray_t,
    pub dstPitch: ::libc::c_uint,
    pub dstHeight: ::libc::c_uint,
    pub WidthInBytes: ::libc::c_uint,
    pub Height: ::libc::c_uint,
    pub Depth: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_HIP_MEMCPY3D() {
    assert_eq!(
        ::std::mem::size_of::<HIP_MEMCPY3D>(),
        128usize,
        concat!("Size of: ", stringify!(HIP_MEMCPY3D))
    );
    assert_eq!(
        ::std::mem::align_of::<HIP_MEMCPY3D>(),
        8usize,
        concat!("Alignment of ", stringify!(HIP_MEMCPY3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcXInBytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcLOD as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcMemoryType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcHost as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcDevice as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcArray as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcPitch as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).srcHeight as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(srcHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstXInBytes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstXInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstY as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstZ as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstLOD as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstLOD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstMemoryType as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstMemoryType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstHost as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstHost)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstDevice as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstArray as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstArray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstPitch as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstPitch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).dstHeight as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(dstHeight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).WidthInBytes as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(WidthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).Height as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(Height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HIP_MEMCPY3D>())).Depth as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(HIP_MEMCPY3D),
            "::",
            stringify!(Depth)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipFunction_attribute {
    HIP_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0,
    HIP_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1,
    HIP_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2,
    HIP_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3,
    HIP_FUNC_ATTRIBUTE_NUM_REGS = 4,
    HIP_FUNC_ATTRIBUTE_PTX_VERSION = 5,
    HIP_FUNC_ATTRIBUTE_BINARY_VERSION = 6,
    HIP_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7,
    HIP_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8,
    HIP_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9,
    HIP_FUNC_ATTRIBUTE_MAX = 10,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar1 {
    pub x: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar1() {
    assert_eq!(
        ::std::mem::size_of::<uchar1>(),
        1usize,
        concat!("Size of: ", stringify!(uchar1))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar1>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar2 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar2() {
    assert_eq!(
        ::std::mem::size_of::<uchar2>(),
        2usize,
        concat!("Size of: ", stringify!(uchar2))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar2>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar2>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar3 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
    pub z: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar3() {
    assert_eq!(
        ::std::mem::size_of::<uchar3>(),
        3usize,
        concat!("Size of: ", stringify!(uchar3))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar3>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar3>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar3>())).z as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(uchar3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uchar4 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
    pub z: ::libc::c_uchar,
    pub w: ::libc::c_uchar,
}
#[test]
fn bindgen_test_layout_uchar4() {
    assert_eq!(
        ::std::mem::size_of::<uchar4>(),
        4usize,
        concat!("Size of: ", stringify!(uchar4))
    );
    assert_eq!(
        ::std::mem::align_of::<uchar4>(),
        1usize,
        concat!("Alignment of ", stringify!(uchar4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar4>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar4>())).z as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uchar4>())).w as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(uchar4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char1 {
    pub x: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_char1() {
    assert_eq!(
        ::std::mem::size_of::<char1>(),
        1usize,
        concat!("Size of: ", stringify!(char1))
    );
    assert_eq!(
        ::std::mem::align_of::<char1>(),
        1usize,
        concat!("Alignment of ", stringify!(char1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char2 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_char2() {
    assert_eq!(
        ::std::mem::size_of::<char2>(),
        2usize,
        concat!("Size of: ", stringify!(char2))
    );
    assert_eq!(
        ::std::mem::align_of::<char2>(),
        1usize,
        concat!("Alignment of ", stringify!(char2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char2>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char3 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
    pub z: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_char3() {
    assert_eq!(
        ::std::mem::size_of::<char3>(),
        3usize,
        concat!("Size of: ", stringify!(char3))
    );
    assert_eq!(
        ::std::mem::align_of::<char3>(),
        1usize,
        concat!("Alignment of ", stringify!(char3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char3>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char3>())).z as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(char3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct char4 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
    pub z: ::libc::c_char,
    pub w: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_char4() {
    assert_eq!(
        ::std::mem::size_of::<char4>(),
        4usize,
        concat!("Size of: ", stringify!(char4))
    );
    assert_eq!(
        ::std::mem::align_of::<char4>(),
        1usize,
        concat!("Alignment of ", stringify!(char4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char4>())).y as *const _ as usize },
        1usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char4>())).z as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<char4>())).w as *const _ as usize },
        3usize,
        concat!("Offset of field: ", stringify!(char4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort1 {
    pub x: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort1() {
    assert_eq!(
        ::std::mem::size_of::<ushort1>(),
        2usize,
        concat!("Size of: ", stringify!(ushort1))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort1>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort2 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort2() {
    assert_eq!(
        ::std::mem::size_of::<ushort2>(),
        4usize,
        concat!("Size of: ", stringify!(ushort2))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort2>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort2>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort3 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
    pub z: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort3() {
    assert_eq!(
        ::std::mem::size_of::<ushort3>(),
        6usize,
        concat!("Size of: ", stringify!(ushort3))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort3>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort3>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort3>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ushort4 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
    pub z: ::libc::c_ushort,
    pub w: ::libc::c_ushort,
}
#[test]
fn bindgen_test_layout_ushort4() {
    assert_eq!(
        ::std::mem::size_of::<ushort4>(),
        8usize,
        concat!("Size of: ", stringify!(ushort4))
    );
    assert_eq!(
        ::std::mem::align_of::<ushort4>(),
        2usize,
        concat!("Alignment of ", stringify!(ushort4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort4>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort4>())).z as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ushort4>())).w as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ushort4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short1 {
    pub x: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_short1() {
    assert_eq!(
        ::std::mem::size_of::<short1>(),
        2usize,
        concat!("Size of: ", stringify!(short1))
    );
    assert_eq!(
        ::std::mem::align_of::<short1>(),
        2usize,
        concat!("Alignment of ", stringify!(short1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short2 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_short2() {
    assert_eq!(
        ::std::mem::size_of::<short2>(),
        4usize,
        concat!("Size of: ", stringify!(short2))
    );
    assert_eq!(
        ::std::mem::align_of::<short2>(),
        2usize,
        concat!("Alignment of ", stringify!(short2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short2>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short3 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
    pub z: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_short3() {
    assert_eq!(
        ::std::mem::size_of::<short3>(),
        6usize,
        concat!("Size of: ", stringify!(short3))
    );
    assert_eq!(
        ::std::mem::align_of::<short3>(),
        2usize,
        concat!("Alignment of ", stringify!(short3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short3>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short3>())).z as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(short3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct short4 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
    pub z: ::libc::c_short,
    pub w: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_short4() {
    assert_eq!(
        ::std::mem::size_of::<short4>(),
        8usize,
        concat!("Size of: ", stringify!(short4))
    );
    assert_eq!(
        ::std::mem::align_of::<short4>(),
        2usize,
        concat!("Alignment of ", stringify!(short4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short4>())).y as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short4>())).z as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<short4>())).w as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(short4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint1 {
    pub x: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_uint1() {
    assert_eq!(
        ::std::mem::size_of::<uint1>(),
        4usize,
        concat!("Size of: ", stringify!(uint1))
    );
    assert_eq!(
        ::std::mem::align_of::<uint1>(),
        4usize,
        concat!("Alignment of ", stringify!(uint1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint2 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_uint2() {
    assert_eq!(
        ::std::mem::size_of::<uint2>(),
        8usize,
        concat!("Size of: ", stringify!(uint2))
    );
    assert_eq!(
        ::std::mem::align_of::<uint2>(),
        4usize,
        concat!("Alignment of ", stringify!(uint2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint3 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_uint3() {
    assert_eq!(
        ::std::mem::size_of::<uint3>(),
        12usize,
        concat!("Size of: ", stringify!(uint3))
    );
    assert_eq!(
        ::std::mem::align_of::<uint3>(),
        4usize,
        concat!("Alignment of ", stringify!(uint3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(uint3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint4 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
    pub w: ::libc::c_uint,
}
#[test]
fn bindgen_test_layout_uint4() {
    assert_eq!(
        ::std::mem::size_of::<uint4>(),
        16usize,
        concat!("Size of: ", stringify!(uint4))
    );
    assert_eq!(
        ::std::mem::align_of::<uint4>(),
        4usize,
        concat!("Alignment of ", stringify!(uint4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint4>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint4>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint4>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(uint4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int1 {
    pub x: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_int1() {
    assert_eq!(
        ::std::mem::size_of::<int1>(),
        4usize,
        concat!("Size of: ", stringify!(int1))
    );
    assert_eq!(
        ::std::mem::align_of::<int1>(),
        4usize,
        concat!("Alignment of ", stringify!(int1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int2 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_int2() {
    assert_eq!(
        ::std::mem::size_of::<int2>(),
        8usize,
        concat!("Size of: ", stringify!(int2))
    );
    assert_eq!(
        ::std::mem::align_of::<int2>(),
        4usize,
        concat!("Alignment of ", stringify!(int2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int3 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_int3() {
    assert_eq!(
        ::std::mem::size_of::<int3>(),
        12usize,
        concat!("Size of: ", stringify!(int3))
    );
    assert_eq!(
        ::std::mem::align_of::<int3>(),
        4usize,
        concat!("Alignment of ", stringify!(int3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(int3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct int4 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_int4() {
    assert_eq!(
        ::std::mem::size_of::<int4>(),
        16usize,
        concat!("Size of: ", stringify!(int4))
    );
    assert_eq!(
        ::std::mem::align_of::<int4>(),
        4usize,
        concat!("Alignment of ", stringify!(int4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int4>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int4>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<int4>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(int4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong1 {
    pub x: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong1() {
    assert_eq!(
        ::std::mem::size_of::<ulong1>(),
        8usize,
        concat!("Size of: ", stringify!(ulong1))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong1>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong2 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong2() {
    assert_eq!(
        ::std::mem::size_of::<ulong2>(),
        16usize,
        concat!("Size of: ", stringify!(ulong2))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong2>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong2>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong3 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
    pub z: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong3() {
    assert_eq!(
        ::std::mem::size_of::<ulong3>(),
        24usize,
        concat!("Size of: ", stringify!(ulong3))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong3>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong3>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong3>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ulong3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulong4 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
    pub z: ::libc::c_ulong,
    pub w: ::libc::c_ulong,
}
#[test]
fn bindgen_test_layout_ulong4() {
    assert_eq!(
        ::std::mem::size_of::<ulong4>(),
        32usize,
        concat!("Size of: ", stringify!(ulong4))
    );
    assert_eq!(
        ::std::mem::align_of::<ulong4>(),
        8usize,
        concat!("Alignment of ", stringify!(ulong4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong4>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong4>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulong4>())).w as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ulong4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long1 {
    pub x: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_long1() {
    assert_eq!(
        ::std::mem::size_of::<long1>(),
        8usize,
        concat!("Size of: ", stringify!(long1))
    );
    assert_eq!(
        ::std::mem::align_of::<long1>(),
        8usize,
        concat!("Alignment of ", stringify!(long1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long2 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_long2() {
    assert_eq!(
        ::std::mem::size_of::<long2>(),
        16usize,
        concat!("Size of: ", stringify!(long2))
    );
    assert_eq!(
        ::std::mem::align_of::<long2>(),
        8usize,
        concat!("Alignment of ", stringify!(long2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long2>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long3 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
    pub z: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_long3() {
    assert_eq!(
        ::std::mem::size_of::<long3>(),
        24usize,
        concat!("Size of: ", stringify!(long3))
    );
    assert_eq!(
        ::std::mem::align_of::<long3>(),
        8usize,
        concat!("Alignment of ", stringify!(long3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long3>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long3>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(long3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct long4 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
    pub z: ::libc::c_long,
    pub w: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_long4() {
    assert_eq!(
        ::std::mem::size_of::<long4>(),
        32usize,
        concat!("Size of: ", stringify!(long4))
    );
    assert_eq!(
        ::std::mem::align_of::<long4>(),
        8usize,
        concat!("Alignment of ", stringify!(long4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long4>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long4>())).z as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<long4>())).w as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(long4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong1 {
    pub x: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong1() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong1>(),
        8usize,
        concat!("Size of: ", stringify!(ulonglong1))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong1>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong2 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong2() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong2>(),
        16usize,
        concat!("Size of: ", stringify!(ulonglong2))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong2>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong2>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong3 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
    pub z: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong3() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong3>(),
        24usize,
        concat!("Size of: ", stringify!(ulonglong3))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong3>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong3>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong3>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ulonglong4 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
    pub z: ::libc::c_ulonglong,
    pub w: ::libc::c_ulonglong,
}
#[test]
fn bindgen_test_layout_ulonglong4() {
    assert_eq!(
        ::std::mem::size_of::<ulonglong4>(),
        32usize,
        concat!("Size of: ", stringify!(ulonglong4))
    );
    assert_eq!(
        ::std::mem::align_of::<ulonglong4>(),
        8usize,
        concat!("Alignment of ", stringify!(ulonglong4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong4>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong4>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ulonglong4>())).w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ulonglong4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong1 {
    pub x: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong1() {
    assert_eq!(
        ::std::mem::size_of::<longlong1>(),
        8usize,
        concat!("Size of: ", stringify!(longlong1))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong1>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong2 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong2() {
    assert_eq!(
        ::std::mem::size_of::<longlong2>(),
        16usize,
        concat!("Size of: ", stringify!(longlong2))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong2>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong2>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong3 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
    pub z: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong3() {
    assert_eq!(
        ::std::mem::size_of::<longlong3>(),
        24usize,
        concat!("Size of: ", stringify!(longlong3))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong3>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong3>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong3>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct longlong4 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
    pub z: ::libc::c_longlong,
    pub w: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_longlong4() {
    assert_eq!(
        ::std::mem::size_of::<longlong4>(),
        32usize,
        concat!("Size of: ", stringify!(longlong4))
    );
    assert_eq!(
        ::std::mem::align_of::<longlong4>(),
        8usize,
        concat!("Alignment of ", stringify!(longlong4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong4>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong4>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<longlong4>())).w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(longlong4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float1 {
    pub x: f32,
}
#[test]
fn bindgen_test_layout_float1() {
    assert_eq!(
        ::std::mem::size_of::<float1>(),
        4usize,
        concat!("Size of: ", stringify!(float1))
    );
    assert_eq!(
        ::std::mem::align_of::<float1>(),
        4usize,
        concat!("Alignment of ", stringify!(float1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float1>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float1), "::", stringify!(x))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_float2() {
    assert_eq!(
        ::std::mem::size_of::<float2>(),
        8usize,
        concat!("Size of: ", stringify!(float2))
    );
    assert_eq!(
        ::std::mem::align_of::<float2>(),
        4usize,
        concat!("Alignment of ", stringify!(float2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float2>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float2>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_float3() {
    assert_eq!(
        ::std::mem::size_of::<float3>(),
        12usize,
        concat!("Size of: ", stringify!(float3))
    );
    assert_eq!(
        ::std::mem::align_of::<float3>(),
        4usize,
        concat!("Alignment of ", stringify!(float3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(float3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct float4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_float4() {
    assert_eq!(
        ::std::mem::size_of::<float4>(),
        16usize,
        concat!("Size of: ", stringify!(float4))
    );
    assert_eq!(
        ::std::mem::align_of::<float4>(),
        4usize,
        concat!("Alignment of ", stringify!(float4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float4>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float4>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float4>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(z))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<float4>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(float4), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double1 {
    pub x: f64,
}
#[test]
fn bindgen_test_layout_double1() {
    assert_eq!(
        ::std::mem::size_of::<double1>(),
        8usize,
        concat!("Size of: ", stringify!(double1))
    );
    assert_eq!(
        ::std::mem::align_of::<double1>(),
        8usize,
        concat!("Alignment of ", stringify!(double1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double1),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_double2() {
    assert_eq!(
        ::std::mem::size_of::<double2>(),
        16usize,
        concat!("Size of: ", stringify!(double2))
    );
    assert_eq!(
        ::std::mem::align_of::<double2>(),
        8usize,
        concat!("Alignment of ", stringify!(double2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double2>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double2>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_double3() {
    assert_eq!(
        ::std::mem::size_of::<double3>(),
        24usize,
        concat!("Size of: ", stringify!(double3))
    );
    assert_eq!(
        ::std::mem::align_of::<double3>(),
        8usize,
        concat!("Alignment of ", stringify!(double3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double3>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double3>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(double3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct double4 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_double4() {
    assert_eq!(
        ::std::mem::size_of::<double4>(),
        32usize,
        concat!("Size of: ", stringify!(double4))
    );
    assert_eq!(
        ::std::mem::align_of::<double4>(),
        8usize,
        concat!("Alignment of ", stringify!(double4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double4>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double4>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<double4>())).w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(double4),
            "::",
            stringify!(w)
        )
    );
}
extern "C" {
    pub fn hipCreateChannelDesc(
        x: ::libc::c_int,
        y: ::libc::c_int,
        z: ::libc::c_int,
        w: ::libc::c_int,
        f: hipChannelFormatKind,
    ) -> hipChannelFormatDesc;
}
#[doc = " An opaque value that represents a hip texture object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hip_texture {
    _unused: [u8; 0],
}
pub type hipTextureObject_t = *mut __hip_texture;
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture address modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipTextureAddressMode {
    hipAddressModeWrap = 0,
    hipAddressModeClamp = 1,
    hipAddressModeMirror = 2,
    hipAddressModeBorder = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture filter modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipTextureFilterMode {
    hipFilterModePoint = 0,
    hipFilterModeLinear = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip texture read modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipTextureReadMode {
    hipReadModeElementType = 0,
    hipReadModeNormalizedFloat = 1,
}
#[doc = " hip texture reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct textureReference {
    pub normalized: ::libc::c_int,
    pub readMode: hipTextureReadMode,
    pub filterMode: hipTextureFilterMode,
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub channelDesc: hipChannelFormatDesc,
    pub sRGB: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
    pub textureObject: hipTextureObject_t,
    pub numChannels: ::libc::c_int,
    pub format: hipArray_Format,
}
#[test]
fn bindgen_test_layout_textureReference() {
    assert_eq!(
        ::std::mem::size_of::<textureReference>(),
        88usize,
        concat!("Size of: ", stringify!(textureReference))
    );
    assert_eq!(
        ::std::mem::align_of::<textureReference>(),
        8usize,
        concat!("Alignment of ", stringify!(textureReference))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).normalized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(normalized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).readMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(readMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).filterMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).addressMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).channelDesc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(channelDesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).sRGB as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(sRGB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).maxAnisotropy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).mipmapFilterMode as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).mipmapLevelBias as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).minMipmapLevelClamp as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<textureReference>())).maxMipmapLevelClamp as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).textureObject as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(textureObject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).numChannels as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(numChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<textureReference>())).format as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(textureReference),
            "::",
            stringify!(format)
        )
    );
}
#[doc = " hip texture descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipTextureDesc {
    pub addressMode: [hipTextureAddressMode; 3usize],
    pub filterMode: hipTextureFilterMode,
    pub readMode: hipTextureReadMode,
    pub sRGB: ::libc::c_int,
    pub borderColor: [f32; 4usize],
    pub normalizedCoords: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: hipTextureFilterMode,
    pub mipmapLevelBias: f32,
    pub minMipmapLevelClamp: f32,
    pub maxMipmapLevelClamp: f32,
}
#[test]
fn bindgen_test_layout_hipTextureDesc() {
    assert_eq!(
        ::std::mem::size_of::<hipTextureDesc>(),
        64usize,
        concat!("Size of: ", stringify!(hipTextureDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<hipTextureDesc>(),
        4usize,
        concat!("Alignment of ", stringify!(hipTextureDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).addressMode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).filterMode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).readMode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(readMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).sRGB as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(sRGB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).borderColor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(borderColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).normalizedCoords as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(normalizedCoords)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).maxAnisotropy as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).mipmapFilterMode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(mipmapFilterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipTextureDesc>())).mipmapLevelBias as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(mipmapLevelBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipTextureDesc>())).minMipmapLevelClamp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(minMipmapLevelClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipTextureDesc>())).maxMipmapLevelClamp as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(hipTextureDesc),
            "::",
            stringify!(maxMipmapLevelClamp)
        )
    );
}
#[doc = " An opaque value that represents a hip surface object"]
pub type hipSurfaceObject_t = ::libc::c_ulonglong;
#[doc = " hip surface reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct surfaceReference {
    pub surfaceObject: hipSurfaceObject_t,
}
#[test]
fn bindgen_test_layout_surfaceReference() {
    assert_eq!(
        ::std::mem::size_of::<surfaceReference>(),
        8usize,
        concat!("Size of: ", stringify!(surfaceReference))
    );
    assert_eq!(
        ::std::mem::align_of::<surfaceReference>(),
        8usize,
        concat!("Alignment of ", stringify!(surfaceReference))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<surfaceReference>())).surfaceObject as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(surfaceReference),
            "::",
            stringify!(surfaceObject)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " hip surface boundary modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipSurfaceBoundaryMode {
    hipBoundaryModeZero = 0,
    hipBoundaryModeTrap = 1,
    hipBoundaryModeClamp = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipCtx_t {
    _unused: [u8; 0],
}
pub type hipCtx_t = *mut ihipCtx_t;
pub type hipDevice_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipIpcMemHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_hipIpcMemHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<hipIpcMemHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(hipIpcMemHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipIpcMemHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(hipIpcMemHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipIpcMemHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipIpcMemHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type hipIpcMemHandle_t = hipIpcMemHandle_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hipIpcEventHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_hipIpcEventHandle_st() {
    assert_eq!(
        ::std::mem::size_of::<hipIpcEventHandle_st>(),
        64usize,
        concat!("Size of: ", stringify!(hipIpcEventHandle_st))
    );
    assert_eq!(
        ::std::mem::align_of::<hipIpcEventHandle_st>(),
        1usize,
        concat!("Alignment of ", stringify!(hipIpcEventHandle_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipIpcEventHandle_st>())).reserved as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipIpcEventHandle_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type hipIpcEventHandle_t = hipIpcEventHandle_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModule_t {
    _unused: [u8; 0],
}
pub type hipModule_t = *mut ihipModule_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipModuleSymbol_t {
    _unused: [u8; 0],
}
pub type hipFunction_t = *mut ihipModuleSymbol_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipFuncAttributes {
    pub binaryVersion: ::libc::c_int,
    pub cacheModeCA: ::libc::c_int,
    pub constSizeBytes: usize,
    pub localSizeBytes: usize,
    pub maxDynamicSharedSizeBytes: ::libc::c_int,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub numRegs: ::libc::c_int,
    pub preferredShmemCarveout: ::libc::c_int,
    pub ptxVersion: ::libc::c_int,
    pub sharedSizeBytes: usize,
}
#[test]
fn bindgen_test_layout_hipFuncAttributes() {
    assert_eq!(
        ::std::mem::size_of::<hipFuncAttributes>(),
        56usize,
        concat!("Size of: ", stringify!(hipFuncAttributes))
    );
    assert_eq!(
        ::std::mem::align_of::<hipFuncAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(hipFuncAttributes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipFuncAttributes>())).binaryVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(binaryVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipFuncAttributes>())).cacheModeCA as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(cacheModeCA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).constSizeBytes as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(constSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).localSizeBytes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(localSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).maxDynamicSharedSizeBytes as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(maxDynamicSharedSizeBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).maxThreadsPerBlock as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(maxThreadsPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipFuncAttributes>())).numRegs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(numRegs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).preferredShmemCarveout as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(preferredShmemCarveout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipFuncAttributes>())).ptxVersion as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(ptxVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<hipFuncAttributes>())).sharedSizeBytes as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipFuncAttributes),
            "::",
            stringify!(sharedSizeBytes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipEvent_t {
    _unused: [u8; 0],
}
pub type hipEvent_t = *mut ihipEvent_t;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipLimit_t {
    hipLimitMallocHeapSize = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipJitOption {
    hipJitOptionMaxRegisters = 0,
    hipJitOptionThreadsPerBlock = 1,
    hipJitOptionWallTime = 2,
    hipJitOptionInfoLogBuffer = 3,
    hipJitOptionInfoLogBufferSizeBytes = 4,
    hipJitOptionErrorLogBuffer = 5,
    hipJitOptionErrorLogBufferSizeBytes = 6,
    hipJitOptionOptimizationLevel = 7,
    hipJitOptionTargetFromContext = 8,
    hipJitOptionTarget = 9,
    hipJitOptionFallbackStrategy = 10,
    hipJitOptionGenerateDebugInfo = 11,
    hipJitOptionLogVerbose = 12,
    hipJitOptionGenerateLineInfo = 13,
    hipJitOptionCacheMode = 14,
    hipJitOptionSm3xOpt = 15,
    hipJitOptionFastCompile = 16,
    hipJitOptionNumOptions = 17,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipFuncCache_t {
    #[doc = "< no preference for shared memory or L1 (default)"]
    hipFuncCachePreferNone = 0,
    #[doc = "< prefer larger shared memory and smaller L1 cache"]
    hipFuncCachePreferShared = 1,
    #[doc = "< prefer larger L1 cache and smaller shared memory"]
    hipFuncCachePreferL1 = 2,
    #[doc = "< prefer equal size L1 cache and shared memory"]
    hipFuncCachePreferEqual = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " @warning On AMD devices and some Nvidia devices, these hints and controls are ignored."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipSharedMemConfig {
    #[doc = "< The compiler selects a device-specific value for the banking."]
    hipSharedMemBankSizeDefault = 0,
    #[doc = "< Shared mem is banked at 4-bytes intervals and performs best"]
    #[doc = "< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeFourByte = 1,
    #[doc = "< Shared mem is banked at 8-byte intervals and performs best"]
    #[doc = "< when adjacent threads access data 4 bytes apart."]
    hipSharedMemBankSizeEightByte = 2,
}
#[doc = " Struct for data in 3D"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dim3 {
    #[doc = "< x"]
    pub x: u32,
    #[doc = "< y"]
    pub y: u32,
    #[doc = "< z"]
    pub z: u32,
}
#[test]
fn bindgen_test_layout_dim3() {
    assert_eq!(
        ::std::mem::size_of::<dim3>(),
        12usize,
        concat!("Size of: ", stringify!(dim3))
    );
    assert_eq!(
        ::std::mem::align_of::<dim3>(),
        4usize,
        concat!("Alignment of ", stringify!(dim3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dim3>())).z as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(dim3), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipLaunchParams_t {
    #[doc = "< Device function symbol"]
    pub func: *mut ::libc::c_void,
    #[doc = "< Grid dimentions"]
    pub gridDim: dim3,
    #[doc = "< Block dimentions"]
    pub blockDim: dim3,
    #[doc = "< Arguments"]
    pub args: *mut *mut ::libc::c_void,
    #[doc = "< Shared memory"]
    pub sharedMem: usize,
    #[doc = "< Stream identifier"]
    pub stream: hipStream_t,
}
#[test]
fn bindgen_test_layout_hipLaunchParams_t() {
    assert_eq!(
        ::std::mem::size_of::<hipLaunchParams_t>(),
        56usize,
        concat!("Size of: ", stringify!(hipLaunchParams_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hipLaunchParams_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipLaunchParams_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).gridDim as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(gridDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).blockDim as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(blockDim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).sharedMem as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(sharedMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipLaunchParams_t>())).stream as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hipLaunchParams_t),
            "::",
            stringify!(stream)
        )
    );
}
pub type hipLaunchParams = hipLaunchParams_t;
extern "C" {
    #[doc = " @brief Waits on all active streams on current device"]
    #[doc = ""]
    #[doc = " When this command is invoked, the host thread gets blocked until all the commands associated"]
    #[doc = " with streams associated with the device. HIP does not support multiple blocking modes (yet!)."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipSetDevice, hipDeviceReset"]
    pub fn hipDeviceSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief The state of current device is discarded and updated to a fresh state."]
    #[doc = ""]
    #[doc = " Calling this function deletes all streams created, memory allocated, kernels running, events"]
    #[doc = " created. Make sure that no other thread is using the device or streams, memory, kernels, events"]
    #[doc = " associated with the current device."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipDeviceSynchronize"]
    pub fn hipDeviceReset() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set default device to be used for subsequent hip API calls from this thread."]
    #[doc = ""]
    #[doc = " @param[in] deviceId Valid device in range 0...hipGetDeviceCount()."]
    #[doc = ""]
    #[doc = " Sets @p device as the default device for the calling host thread.  Valid device id's are 0..."]
    #[doc = " (hipGetDeviceCount()-1)."]
    #[doc = ""]
    #[doc = " Many HIP APIs implicitly use the \"default device\" :"]
    #[doc = ""]
    #[doc = " - Any device memory subsequently allocated from this host thread (using hipMalloc) will be"]
    #[doc = " allocated on device."]
    #[doc = " - Any streams or events created from this host thread will be associated with device."]
    #[doc = " - Any kernels launched from this host thread (using hipLaunchKernel) will be executed on device"]
    #[doc = " (unless a specific stream is specified, in which case the device associated with that stream will"]
    #[doc = " be used)."]
    #[doc = ""]
    #[doc = " This function may be called from any host thread.  Multiple host threads may use the same device."]
    #[doc = " This function does no synchronization with the previous or new device, and has very little"]
    #[doc = " runtime overhead. Applications can use hipSetDevice to quickly switch the default device before"]
    #[doc = " making a HIP runtime call which uses the default device."]
    #[doc = ""]
    #[doc = " The default device is stored in thread-local-storage for each thread."]
    #[doc = " Thread-pool implementations may inherit the default device of the previous thread.  A good"]
    #[doc = " practice is to always call hipSetDevice at the start of HIP coding sequency to establish a known"]
    #[doc = " standard device."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorDeviceAlreadyInUse"]
    #[doc = ""]
    #[doc = " @see hipGetDevice, hipGetDeviceCount"]
    pub fn hipSetDevice(deviceId: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the default device id for the calling host thread."]
    #[doc = ""]
    #[doc = " @param [out] device *device is written with the default device"]
    #[doc = ""]
    #[doc = " HIP maintains an default device for each thread using thread-local-storage."]
    #[doc = " This device is used implicitly for HIP runtime APIs called by this thread."]
    #[doc = " hipGetDevice returns in * @p device the default device for the calling host thread."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipSetDevice, hipGetDevicesizeBytes"]
    pub fn hipGetDevice(deviceId: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return number of compute-capable devices."]
    #[doc = ""]
    #[doc = " @param [output] count Returns number of compute-capable devices."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNoDevice"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Returns in @p *count the number of devices that have ability to run compute commands.  If there"]
    #[doc = " are no such devices, then @ref hipGetDeviceCount will return #hipErrorNoDevice. If 1 or more"]
    #[doc = " devices can be found, then hipGetDeviceCount returns #hipSuccess."]
    pub fn hipGetDeviceCount(count: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query for a specific device attribute."]
    #[doc = ""]
    #[doc = " @param [out] pi pointer to value to return"]
    #[doc = " @param [in] attr attribute to query"]
    #[doc = " @param [in] deviceId which device to query for information"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetAttribute(
        pi: *mut ::libc::c_int,
        attr: hipDeviceAttribute_t,
        deviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns device properties."]
    #[doc = ""]
    #[doc = " @param [out] prop written with device properties"]
    #[doc = " @param [in]  deviceId which device to query for information"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidDevice"]
    #[doc = " @bug HCC always returns 0 for maxThreadsPerMultiProcessor"]
    #[doc = " @bug HCC always returns 0 for regsPerBlock"]
    #[doc = " @bug HCC always returns 0 for l2CacheSize"]
    #[doc = ""]
    #[doc = " Populates hipGetDeviceProperties with information for the specified device."]
    pub fn hipGetDeviceProperties(
        prop: *mut hipDeviceProp_t,
        deviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition."]
    #[doc = ""]
    #[doc = " @param [in] cacheConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipDeviceSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [in] cacheConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipDeviceGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Resource limits of current device"]
    #[doc = ""]
    #[doc = " @param [out] pValue"]
    #[doc = " @param [in]  limit"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorUnsupportedLimit, #hipErrorInvalidValue"]
    #[doc = " Note: Currently, only hipLimitMallocHeapSize is available"]
    #[doc = ""]
    pub fn hipDeviceGetLimit(pValue: *mut usize, limit: hipLimit_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [in] config;"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized"]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is ignored"]
    #[doc = " on those architectures."]
    #[doc = ""]
    pub fn hipFuncSetCacheConfig(func: *const ::libc::c_void, config: hipFuncCache_t)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns bank width of shared memory for current device"]
    #[doc = ""]
    #[doc = " @param [out] pConfig"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    pub fn hipDeviceGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The bank width of shared memory on current device is set"]
    #[doc = ""]
    #[doc = " @param [in] config"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = " Note: AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    pub fn hipDeviceSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief The current device behavior is changed according the flags passed."]
    #[doc = ""]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " The schedule flags impact how HIP waits for the completion of a command running on a device."]
    #[doc = " hipDeviceScheduleSpin         : HIP runtime will actively spin in the thread which submitted the"]
    #[doc = " work until the command completes.  This offers the lowest latency, but will consume a CPU core"]
    #[doc = " and may increase power. hipDeviceScheduleYield        : The HIP runtime will yield the CPU to"]
    #[doc = " system so that other tasks can use it.  This may increase latency to detect the completion but"]
    #[doc = " will consume less power and is friendlier to other tasks in the system."]
    #[doc = " hipDeviceScheduleBlockingSync : On ROCm platform, this is a synonym for hipDeviceScheduleYield."]
    #[doc = " hipDeviceScheduleAuto         : Use a hueristic to select between Spin and Yield modes.  If the"]
    #[doc = " number of HIP contexts is greater than the number of logical processors in the system, use Spin"]
    #[doc = " scheduling.  Else use Yield scheduling."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " hipDeviceMapHost              : Allow mapping host memory.  On ROCM, this is always allowed and"]
    #[doc = " the flag is ignored. hipDeviceLmemResizeToMax      : @warning ROCm silently ignores this flag."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorSetOnActiveProcess"]
    #[doc = ""]
    #[doc = ""]
    pub fn hipSetDeviceFlags(flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Device which matches hipDeviceProp_t is returned"]
    #[doc = ""]
    #[doc = " @param [out] device ID"]
    #[doc = " @param [in]  device properties pointer"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipChooseDevice(device: *mut ::libc::c_int, prop: *const hipDeviceProp_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the link type and hop count between two devices"]
    #[doc = ""]
    #[doc = " @param [in] device1 Ordinal for device1"]
    #[doc = " @param [in] device2 Ordinal for device2"]
    #[doc = " @param [out] linktype Returns the link type (See hsa_amd_link_info_type_t) between the two devices"]
    #[doc = " @param [out] hopcount Returns the hop count between the two devices"]
    #[doc = ""]
    #[doc = " Queries and returns the HSA link type and the hop count between the two specified devices."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipInvalidDevice, #hipErrorRuntimeOther"]
    pub fn hipExtGetLinkTypeAndHopCount(
        device1: ::libc::c_int,
        device2: ::libc::c_int,
        linktype: *mut u32,
        hopcount: *mut u32,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call and resets the stored error code to"]
    #[doc = " #hipSuccess"]
    #[doc = ""]
    #[doc = " @returns return code from last HIP called from the active host thread"]
    #[doc = ""]
    #[doc = " Returns the last error that has been returned by any of the runtime calls in the same host"]
    #[doc = " thread, and then resets the saved error to #hipSuccess."]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return last error returned by any HIP runtime API call."]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " Returns the last error that has been returned by any of the runtime calls in the same host"]
    #[doc = " thread. Unlike hipGetLastError, this function does not reset the saved error code."]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipPeekAtLastError() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return name of the specified error code in text form."]
    #[doc = ""]
    #[doc = " @param hip_error Error code to convert to name."]
    #[doc = " @return const char pointer to the NULL-terminated error name"]
    #[doc = ""]
    #[doc = " @see hipGetErrorString, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorName(hip_error: hipError_t) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Return handy text string message to explain the error which occurred"]
    #[doc = ""]
    #[doc = " @param hipError Error code to convert to string."]
    #[doc = " @return const char pointer to the NULL-terminated error string"]
    #[doc = ""]
    #[doc = " @warning : on HCC, this function returns the name of the error (same as hipGetErrorName)"]
    #[doc = ""]
    #[doc = " @see hipGetErrorName, hipGetLastError, hipPeakAtLastError, hipError_t"]
    pub fn hipGetErrorString(hipError: hipError_t) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the"]
    #[doc = " newly created stream."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to"]
    #[doc = " reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on"]
    #[doc = " the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory"]
    #[doc = " used by the stream, applicaiton must call hipStreamDestroy."]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreate(stream: *mut hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Pointer to new stream"]
    #[doc = " @param[in ] flags to control stream creation."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream.  @p stream returns an opaque handle that can be used to"]
    #[doc = " reference the newly created stream in subsequent hipStream* commands.  The stream is allocated on"]
    #[doc = " the heap and will remain allocated even if the handle goes out-of-scope.  To release the memory"]
    #[doc = " used by the stream, applicaiton must call hipStreamDestroy. Flags controls behavior of the"]
    #[doc = " stream.  See #hipStreamDefault, #hipStreamNonBlocking."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithFlags(stream: *mut hipStream_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an asynchronous stream with the specified priority."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Pointer to new stream"]
    #[doc = " @param[in ] flags to control stream creation."]
    #[doc = " @param[in ] priority of the stream. Lower numbers represent higher priorities."]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " Create a new asynchronous stream with the specified priority.  @p stream returns an opaque handle"]
    #[doc = " that can be used to reference the newly created stream in subsequent hipStream* commands.  The"]
    #[doc = " stream is allocated on the heap and will remain allocated even if the handle goes out-of-scope."]
    #[doc = " To release the memory used by the stream, applicaiton must call hipStreamDestroy. Flags controls"]
    #[doc = " behavior of the stream.  See #hipStreamDefault, #hipStreamNonBlocking."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamSynchronize, hipStreamWaitEvent, hipStreamDestroy"]
    pub fn hipStreamCreateWithPriority(
        stream: *mut hipStream_t,
        flags: ::libc::c_uint,
        priority: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns numerical values that correspond to the least and greatest stream priority."]
    #[doc = ""]
    #[doc = " @param[in, out] leastPriority pointer in which value corresponding to least priority is returned."]
    #[doc = " @param[in, out] greatestPriority pointer in which value corresponding to greatest priority is returned."]
    #[doc = ""]
    #[doc = " Returns in *leastPriority and *greatestPriority the numerical values that correspond to the least"]
    #[doc = " and greatest stream priority respectively. Stream priorities follow a convention where lower numbers"]
    #[doc = " imply greater priorities. The range of meaningful stream priorities is given by"]
    #[doc = " [*greatestPriority, *leastPriority]. If the user attempts to create a stream with a priority value"]
    #[doc = " that is outside the the meaningful range as specified by this API, the priority is automatically"]
    #[doc = " clamped to within the valid range."]
    pub fn hipDeviceGetStreamPriorityRange(
        leastPriority: *mut ::libc::c_int,
        greatestPriority: *mut ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroys the specified stream."]
    #[doc = ""]
    #[doc = " @param[in, out] stream Valid pointer to hipStream_t.  This function writes the memory with the"]
    #[doc = " newly created stream."]
    #[doc = " @return #hipSuccess #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Destroys the specified stream."]
    #[doc = ""]
    #[doc = " If commands are still executing on the specified stream, some may complete execution before the"]
    #[doc = " queue is deleted."]
    #[doc = ""]
    #[doc = " The queue may be destroyed while some commands are still inflight, or may wait for all commands"]
    #[doc = " queued to the stream before destroying it."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamQuery, hipStreamWaitEvent,"]
    #[doc = " hipStreamSynchronize"]
    pub fn hipStreamDestroy(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return #hipSuccess if all of the operations in the specified @p stream have completed, or"]
    #[doc = " #hipErrorNotReady if not."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to query"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This is thread-safe and returns a snapshot of the current state of the queue.  However, if other"]
    #[doc = " host threads are sending work to the stream, the status may change immediately after the function"]
    #[doc = " is called.  It is typically used for debug."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamSynchronize,"]
    #[doc = " hipStreamDestroy"]
    pub fn hipStreamQuery(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Wait for all commands in stream to complete."]
    #[doc = ""]
    #[doc = " @param[in] stream stream identifier."]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This command is host-synchronous : the host will block until the specified stream is empty."]
    #[doc = ""]
    #[doc = " This command follows standard null-stream semantics.  Specifically, specifying the null stream"]
    #[doc = " will cause the command to wait for other streams on the same device to complete all pending"]
    #[doc = " operations."]
    #[doc = ""]
    #[doc = " This command honors the hipDeviceLaunchBlocking flag, which controls whether the wait is active"]
    #[doc = " or blocking."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamWaitEvent, hipStreamDestroy"]
    #[doc = ""]
    pub fn hipStreamSynchronize(stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Make the specified compute stream wait for an event"]
    #[doc = ""]
    #[doc = " @param[in] stream stream to make wait."]
    #[doc = " @param[in] event event to wait on"]
    #[doc = " @param[in] flags control operation [must be 0]"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " This function inserts a wait operation into the specified stream."]
    #[doc = " All future work submitted to @p stream will wait until @p event reports completion before"]
    #[doc = " beginning execution."]
    #[doc = ""]
    #[doc = " This function only waits for commands in the current stream to complete.  Notably,, this function"]
    #[doc = " does not impliciy wait for commands in the default stream to complete, even if the specified"]
    #[doc = " stream is created with hipStreamNonBlocking = 0."]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamCreateWithPriority, hipStreamSynchronize, hipStreamDestroy"]
    pub fn hipStreamWaitEvent(
        stream: hipStream_t,
        event: hipEvent_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags associated with this stream."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to be queried"]
    #[doc = " @param[in,out] flags Pointer to an unsigned integer in which the stream's flags are returned"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Return flags associated with this stream in *@p flags."]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetFlags(stream: hipStream_t, flags: *mut ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query the priority of a stream."]
    #[doc = ""]
    #[doc = " @param[in] stream stream to be queried"]
    #[doc = " @param[in,out] priority Pointer to an unsigned integer in which the stream's priority is returned"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess #hipErrorInvalidValue #hipErrorInvalidHandle"]
    #[doc = ""]
    #[doc = " Query the priority of a stream. The priority is returned in in priority."]
    #[doc = ""]
    #[doc = " @see hipStreamCreateWithFlags"]
    pub fn hipStreamGetPriority(stream: hipStream_t, priority: *mut ::libc::c_int) -> hipError_t;
}
#[doc = " Stream CallBack struct"]
pub type hipStreamCallback_t = ::std::option::Option<
    unsafe extern "C" fn(stream: hipStream_t, status: hipError_t, userData: *mut ::libc::c_void),
>;
extern "C" {
    #[doc = " @brief Adds a callback to be called on the host after all currently enqueued"]
    #[doc = " items in the stream have completed.  For each"]
    #[doc = " cudaStreamAddCallback call, a callback will be executed exactly once."]
    #[doc = " The callback will block later work in the stream until it is finished."]
    #[doc = " @param[in] stream   - Stream to add callback to"]
    #[doc = " @param[in] callback - The function to call once preceding stream operations are complete"]
    #[doc = " @param[in] userData - User specified data to be passed to the callback function"]
    #[doc = " @param[in] flags    - Reserved for future use, must be 0"]
    #[doc = " @return #hipSuccess, #hipErrorInvalidHandle, #hipErrorNotSupported"]
    #[doc = ""]
    #[doc = " @see hipStreamCreate, hipStreamCreateWithFlags, hipStreamQuery, hipStreamSynchronize,"]
    #[doc = " hipStreamWaitEvent, hipStreamDestroy, hipStreamCreateWithPriority"]
    #[doc = ""]
    pub fn hipStreamAddCallback(
        stream: hipStream_t,
        callback: hipStreamCallback_t,
        userData: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create an event with the specified flags"]
    #[doc = ""]
    #[doc = " @param[in,out] event Returns the newly created event."]
    #[doc = " @param[in] flags     Flags to control event behavior.  Valid values are #hipEventDefault,"]
    #[doc = "#hipEventBlockingSync, #hipEventDisableTiming, #hipEventInterprocess"]
    #[doc = ""]
    #[doc = " #hipEventDefault : Default flag.  The event will use active synchronization and will support"]
    #[doc = "timing.  Blocking synchronization provides lowest possible latency at the expense of dedicating a"]
    #[doc = "CPU to poll on the event."]
    #[doc = " #hipEventBlockingSync : The event will use blocking synchronization : if hipEventSynchronize is"]
    #[doc = "called on this event, the thread will block until the event completes.  This can increase latency"]
    #[doc = "for the synchroniation but can result in lower power and more resources for other CPU threads."]
    #[doc = " #hipEventDisableTiming : Disable recording of timing information.  On ROCM platform, timing"]
    #[doc = "information is always recorded and this flag has no performance benefit."]
    #[doc = ""]
    #[doc = " @warning On HCC platform, hipEventInterprocess support is under development.  Use of this flag"]
    #[doc = "will return an error."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = "#hipErrorLaunchFailure, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventSynchronize, hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreateWithFlags(event: *mut hipEvent_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = "  Create an event"]
    #[doc = ""]
    #[doc = " @param[in,out] event Returns the newly created event."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorLaunchFailure, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = " @see hipEventCreateWithFlags, hipEventRecord, hipEventQuery, hipEventSynchronize,"]
    #[doc = " hipEventDestroy, hipEventElapsedTime"]
    pub fn hipEventCreate(event: *mut hipEvent_t) -> hipError_t;
}
extern "C" {
    pub fn hipEventRecord(event: hipEvent_t, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Destroy the specified event."]
    #[doc = ""]
    #[doc = "  @param[in] event Event to destroy."]
    #[doc = "  @returns #hipSuccess, #hipErrorNotInitialized, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = "  Releases memory associated with the event.  If the event is recording but has not completed"]
    #[doc = " recording when hipEventDestroy() is called, the function will return immediately and the"]
    #[doc = " completion_future resources will be released later, when the hipDevice is synchronized."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventSynchronize, hipEventRecord,"]
    #[doc = " hipEventElapsedTime"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    pub fn hipEventDestroy(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Wait for an event to complete."]
    #[doc = ""]
    #[doc = "  This function will block until the event is ready, waiting for all previous work in the stream"]
    #[doc = " specified when event was recorded with hipEventRecord()."]
    #[doc = ""]
    #[doc = "  If hipEventRecord() has not been called on @p event, this function returns immediately."]
    #[doc = ""]
    #[doc = "  TODO-hcc - This function needs to support hipEventBlockingSync parameter."]
    #[doc = ""]
    #[doc = "  @param[in] event Event on which to wait."]
    #[doc = "  @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized,"]
    #[doc = " #hipErrorInvalidHandle, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = "  @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,"]
    #[doc = " hipEventElapsedTime"]
    pub fn hipEventSynchronize(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return the elapsed time between two events."]
    #[doc = ""]
    #[doc = " @param[out] ms : Return time between start and stop in ms."]
    #[doc = " @param[in]   start : Start event."]
    #[doc = " @param[in]   stop  : Stop event."]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorNotReady, #hipErrorInvalidHandle,"]
    #[doc = " #hipErrorNotInitialized, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = " Computes the elapsed time between two events. Time is computed in ms, with"]
    #[doc = " a resolution of approximately 1 us."]
    #[doc = ""]
    #[doc = " Events which are recorded in a NULL stream will block until all commands"]
    #[doc = " on all other streams complete execution, and then record the timestamp."]
    #[doc = ""]
    #[doc = " Events which are recorded in a non-NULL stream will record their timestamp"]
    #[doc = " when they reach the head of the specified stream, after all previous"]
    #[doc = " commands in that stream have completed executing.  Thus the time that"]
    #[doc = " the event recorded may be significantly after the host calls hipEventRecord()."]
    #[doc = ""]
    #[doc = " If hipEventRecord() has not been called on either event, then #hipErrorInvalidHandle is"]
    #[doc = " returned. If hipEventRecord() has been called on both events, but the timestamp has not yet been"]
    #[doc = " recorded on one or both events (that is, hipEventQuery() would return #hipErrorNotReady on at"]
    #[doc = " least one of the events), then #hipErrorNotReady is returned."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventQuery, hipEventDestroy, hipEventRecord,"]
    #[doc = " hipEventSynchronize"]
    pub fn hipEventElapsedTime(ms: *mut f32, start: hipEvent_t, stop: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query event status"]
    #[doc = ""]
    #[doc = " @param[in] event Event to query."]
    #[doc = " @returns #hipSuccess, #hipErrorNotReady, #hipErrorInvalidHandle, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorNotInitialized, #hipErrorLaunchFailure"]
    #[doc = ""]
    #[doc = " Query the status of the specified event.  This function will return #hipErrorNotReady if all"]
    #[doc = " commands in the appropriate stream (specified to hipEventRecord()) have completed.  If that work"]
    #[doc = " has not completed, or if hipEventRecord() was not called on the event, then #hipSuccess is"]
    #[doc = " returned."]
    #[doc = ""]
    #[doc = " @see hipEventCreate, hipEventCreateWithFlags, hipEventRecord, hipEventDestroy,"]
    #[doc = " hipEventSynchronize, hipEventElapsedTime"]
    pub fn hipEventQuery(event: hipEvent_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return attributes for the specified pointer"]
    #[doc = ""]
    #[doc = "  @param[out] attributes for the specified pointer"]
    #[doc = "  @param[in]  pointer to get attributes for"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipGetDeviceCount, hipGetDevice, hipSetDevice, hipChooseDevice"]
    pub fn hipPointerGetAttributes(
        attributes: *mut hipPointerAttribute_t,
        ptr: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)"]
    #[doc = ""]
    #[doc = "  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,"]
    #[doc = " hipHostFree, hipHostMalloc"]
    pub fn hipMalloc(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate memory on the default accelerator"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory, #hipErrorInvalidValue (bad context, null *ptr)"]
    #[doc = ""]
    #[doc = "  @see hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D, hipMalloc3DArray,"]
    #[doc = " hipHostFree, hipHostMalloc"]
    pub fn hipExtMallocWithFlags(
        ptr: *mut *mut ::libc::c_void,
        sizeBytes: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipMallocHost(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate pinned host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipMemAllocHost(ptr: *mut *mut ::libc::c_void, size: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of host memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipSetDeviceFlags, hipHostFree"]
    pub fn hipHostMalloc(
        ptr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocates memory that will be automatically managed by the Unified Memory system."]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated managed memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags must be either hipMemAttachGlobal/hipMemAttachHost"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    pub fn hipMallocManaged(
        devPtr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate device accessible page locked host memory [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated host pinned memory"]
    #[doc = "  @param[in]  size Requested memory size"]
    #[doc = "  @param[in]  flags Type of host memory allocation"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostMalloc() instead"]
    pub fn hipHostAlloc(
        ptr: *mut *mut ::libc::c_void,
        size: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Get Device pointer from Host Pointer allocated through hipHostMalloc"]
    #[doc = ""]
    #[doc = "  @param[out] dstPtr Device Pointer mapped to passed host pointer"]
    #[doc = "  @param[in]  hstPtr Host Pointer allocated through hipHostMalloc"]
    #[doc = "  @param[in]  flags Flags to be passed for extension"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipSetDeviceFlags, hipHostMalloc"]
    pub fn hipHostGetDevicePointer(
        devPtr: *mut *mut ::libc::c_void,
        hstPtr: *mut ::libc::c_void,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Return flags associated with host pointer"]
    #[doc = ""]
    #[doc = "  @param[out] flagsPtr Memory location to store flags"]
    #[doc = "  @param[in]  hostPtr Host Pointer allocated through hipHostMalloc"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipHostMalloc"]
    pub fn hipHostGetFlags(
        flagsPtr: *mut ::libc::c_uint,
        hostPtr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Register host memory so it can be accessed from the current device."]
    #[doc = ""]
    #[doc = "  @param[out] hostPtr Pointer to host memory to be registered."]
    #[doc = "  @param[in] sizeBytes size of the host memory"]
    #[doc = "  @param[in] flags.  See below."]
    #[doc = ""]
    #[doc = "  Flags:"]
    #[doc = "  - #hipHostRegisterDefault   Memory is Mapped and Portable"]
    #[doc = "  - #hipHostRegisterPortable  Memory is considered registered by all contexts.  HIP only supports"]
    #[doc = " one context so this is always assumed true."]
    #[doc = "  - #hipHostRegisterMapped    Map the allocation into the address space for the current device."]
    #[doc = " The device pointer can be obtained with #hipHostGetDevicePointer."]
    #[doc = ""]
    #[doc = ""]
    #[doc = "  After registering the memory, use #hipHostGetDevicePointer to obtain the mapped device pointer."]
    #[doc = "  On many systems, the mapped device pointer will have a different value than the mapped host"]
    #[doc = " pointer.  Applications must use the device pointer in device code, and the host pointer in device"]
    #[doc = " code."]
    #[doc = ""]
    #[doc = "  On some systems, registered memory is pinned.  On some systems, registered memory may not be"]
    #[doc = " actually be pinned but uses OS or hardware facilities to all GPU access to the host memory."]
    #[doc = ""]
    #[doc = "  Developers are strongly encouraged to register memory blocks which are aligned to the host"]
    #[doc = " cache-line size. (typically 64-bytes but can be obtains from the CPUID instruction)."]
    #[doc = ""]
    #[doc = "  If registering non-aligned pointers, the application must take care when register pointers from"]
    #[doc = " the same cache line on different devices.  HIP's coarse-grained synchronization model does not"]
    #[doc = " guarantee correct results if different devices write to different parts of the same cache block -"]
    #[doc = " typically one of the writes will \"win\" and overwrite data from the other registered memory"]
    #[doc = " region."]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipHostUnregister, hipHostGetFlags, hipHostGetDevicePointer"]
    pub fn hipHostRegister(
        hostPtr: *mut ::libc::c_void,
        sizeBytes: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Un-register host pointer"]
    #[doc = ""]
    #[doc = "  @param[in] hostPtr Host pointer previously registered with #hipHostRegister"]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipHostRegister"]
    pub fn hipHostUnregister(hostPtr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory"]
    #[doc = "  Padding may occur to ensure alighnment requirements are met for the given row"]
    #[doc = "  The change in width size due to padding will be returned in *pitch."]
    #[doc = "  Currently the alignment is set to 128 bytes"]
    #[doc = ""]
    #[doc = "  @param[out] ptr Pointer to the allocated device memory"]
    #[doc = "  @param[out] pitch Pitch for allocation (in bytes)"]
    #[doc = "  @param[in]  width Requested pitched allocation width (in bytes)"]
    #[doc = "  @param[in]  height Requested pitched allocation height"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMallocPitch(
        ptr: *mut *mut ::libc::c_void,
        pitch: *mut usize,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  Allocates at least width (in bytes) * height bytes of linear memory"]
    #[doc = "  Padding may occur to ensure alighnment requirements are met for the given row"]
    #[doc = "  The change in width size due to padding will be returned in *pitch."]
    #[doc = "  Currently the alignment is set to 128 bytes"]
    #[doc = ""]
    #[doc = "  @param[out] dptr Pointer to the allocated device memory"]
    #[doc = "  @param[out] pitch Pitch for allocation (in bytes)"]
    #[doc = "  @param[in]  width Requested pitched allocation width (in bytes)"]
    #[doc = "  @param[in]  height Requested pitched allocation height"]
    #[doc = ""]
    #[doc = "  If size is 0, no memory is allocated, *ptr returns nullptr, and hipSuccess is returned."]
    #[doc = "  The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array."]
    #[doc = "  Given the row and column of an array element of type T, the address is computed as:"]
    #[doc = "  T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;"]
    #[doc = ""]
    #[doc = "  @return Error code"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipFree, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipMemAllocPitch(
        dptr: *mut hipDeviceptr_t,
        pitch: *mut usize,
        widthInBytes: usize,
        height: usize,
        elementSizeBytes: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip memory allocation API."]
    #[doc = "  This API performs an implicit hipDeviceSynchronize() call."]
    #[doc = "  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess"]
    #[doc = "  @return #hipErrorInvalidDevicePointer (if pointer is invalid, including host pointers allocated"]
    #[doc = " with hipHostMalloc)"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipMallocArray, hipFreeArray, hipHostFree, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipFree(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API.  [Deprecated]"]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess,"]
    #[doc = "          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with"]
    #[doc = "hipMalloc)"]
    #[doc = ""]
    #[doc = "  @deprecated use hipHostFree() instead"]
    pub fn hipFreeHost(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Free memory allocated by the hcc hip host memory allocation API"]
    #[doc = "  This API performs an implicit hipDeviceSynchronize() call."]
    #[doc = "  If pointer is NULL, the hip runtime is initialized and hipSuccess is returned."]
    #[doc = ""]
    #[doc = "  @param[in] ptr Pointer to memory to be freed"]
    #[doc = "  @return #hipSuccess,"]
    #[doc = "          #hipErrorInvalidValue (if pointer is invalid, including device pointers allocated with"]
    #[doc = " hipMalloc)"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipFreeArray, hipMalloc3D,"]
    #[doc = " hipMalloc3DArray, hipHostMalloc"]
    pub fn hipHostFree(ptr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst."]
    #[doc = ""]
    #[doc = "  It supports memory from host to device,"]
    #[doc = "  device to host, device to device and host to host"]
    #[doc = "  The src and dst must not overlap."]
    #[doc = ""]
    #[doc = "  For hipMemcpy, the copy is always performed by the current device (set by hipSetDevice)."]
    #[doc = "  For multi-gpu or peer-to-peer configurations, it is recommended to set the current device to the"]
    #[doc = " device where the src data is physically located. For optimal peer-to-peer copies, the copy device"]
    #[doc = " must be able to access the src and dst pointers (by calling hipDeviceEnablePeerAccess with copy"]
    #[doc = " agent as the current device and src/dest as the peerDevice argument.  if this is not done, the"]
    #[doc = " hipMemcpy will still work, but will perform the copy using a staging buffer on the host."]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]  src Data being copy from"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @param[in]  copyType Memory copy type"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknowni"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpy(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMemcpyWithStream(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoD(
        dst: hipDeviceptr_t,
        src: *mut ::libc::c_void,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoH(
        dst: *mut ::libc::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoD(dst: hipDeviceptr_t, src: hipDeviceptr_t, sizeBytes: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Host to Device asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyHtoDAsync(
        dst: hipDeviceptr_t,
        src: *mut ::libc::c_void,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Host asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoHAsync(
        dst: *mut ::libc::c_void,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from Device to Device asynchronously"]
    #[doc = ""]
    #[doc = "  @param[out]  dst Data being copy to"]
    #[doc = "  @param[in]   src Data being copy from"]
    #[doc = "  @param[in]   sizeBytes Data size in bytes"]
    #[doc = ""]
    #[doc = "  @return #hipSuccess, #hipErrorDeInitialized, #hipErrorNotInitialized, #hipErrorInvalidContext,"]
    #[doc = " #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = "  @see hipArrayCreate, hipArrayDestroy, hipArrayGetDescriptor, hipMemAlloc, hipMemAllocHost,"]
    #[doc = " hipMemAllocPitch, hipMemcpy2D, hipMemcpy2DAsync, hipMemcpy2DUnaligned, hipMemcpyAtoA,"]
    #[doc = " hipMemcpyAtoD, hipMemcpyAtoH, hipMemcpyAtoHAsync, hipMemcpyDtoA, hipMemcpyDtoD,"]
    #[doc = " hipMemcpyDtoDAsync, hipMemcpyDtoH, hipMemcpyDtoHAsync, hipMemcpyHtoA, hipMemcpyHtoAAsync,"]
    #[doc = " hipMemcpyHtoDAsync, hipMemFree, hipMemFreeHost, hipMemGetAddressRange, hipMemGetInfo,"]
    #[doc = " hipMemHostAlloc, hipMemHostGetDevicePointer"]
    pub fn hipMemcpyDtoDAsync(
        dst: hipDeviceptr_t,
        src: hipDeviceptr_t,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief returns device memory pointer and size of the kernel present in the module with symbol @p"]
    #[doc = " name"]
    #[doc = ""]
    #[doc = " @param [out] dptr"]
    #[doc = " @param [out] bytes"]
    #[doc = " @param [in] hmod"]
    #[doc = " @param [in] name"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorNotInitialized"]
    pub fn hipModuleGetGlobal(
        arg1: *mut *mut ::libc::c_void,
        arg2: *mut usize,
        arg3: hipModule_t,
        arg4: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copy data from src to dst asynchronously."]
    #[doc = ""]
    #[doc = "  @warning If host or dest are not pinned, the memory copy will be performed synchronously.  For"]
    #[doc = " best performance, use hipHostMalloc to allocate host memory that is transferred asynchronously."]
    #[doc = ""]
    #[doc = "  @warning on HCC hipMemcpyAsync does not support overlapped H2D and D2H copies."]
    #[doc = "  For hipMemcpy, the copy is always performed by the device associated with the specified stream."]
    #[doc = ""]
    #[doc = "  For multi-gpu or peer-to-peer configurations, it is recommended to use a stream which is a"]
    #[doc = " attached to the device where the src data is physically located. For optimal peer-to-peer copies,"]
    #[doc = " the copy device must be able to access the src and dst pointers (by calling"]
    #[doc = " hipDeviceEnablePeerAccess with copy agent as the current device and src/dest as the peerDevice"]
    #[doc = " argument.  if this is not done, the hipMemcpy will still work, but will perform the copy using a"]
    #[doc = " staging buffer on the host."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being copy to"]
    #[doc = "  @param[in]  src Data being copy from"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @param[in]  accelerator_view Accelerator view which the copy is being enqueued"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree, #hipErrorUnknown"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpy2DFromArray, hipMemcpyArrayToArray, hipMemcpy2DArrayToArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyFromSymbol, hipMemcpy2DAsync, hipMemcpyToArrayAsync, hipMemcpy2DToArrayAsync,"]
    #[doc = " hipMemcpyFromArrayAsync, hipMemcpy2DFromArrayAsync, hipMemcpyToSymbolAsync,"]
    #[doc = " hipMemcpyFromSymbolAsync"]
    pub fn hipMemcpyAsync(
        dst: *mut ::libc::c_void,
        src: *const ::libc::c_void,
        sizeBytes: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  sizeBytes Data size in bytes"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemset(
        dst: *mut ::libc::c_void,
        value: ::libc::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8(dest: hipDeviceptr_t, value: ::libc::c_uchar, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = " hipMemsetD8Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD8Async(
        dest: hipDeviceptr_t,
        value: ::libc::c_uchar,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " short value value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16(dest: hipDeviceptr_t, value: ::libc::c_ushort, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dest with the constant"]
    #[doc = " short value value."]
    #[doc = ""]
    #[doc = " hipMemsetD16Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data ptr to be filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD16Async(
        dest: hipDeviceptr_t,
        value: ::libc::c_ushort,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dest with the constant integer"]
    #[doc = " value for specified number of times."]
    #[doc = ""]
    #[doc = "  @param[out] dst Data being filled"]
    #[doc = "  @param[in]  constant value to be set"]
    #[doc = "  @param[in]  number of values to be set"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    pub fn hipMemsetD32(dest: hipDeviceptr_t, value: ::libc::c_int, count: usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the first sizeBytes bytes of the memory area pointed to by dev with the constant"]
    #[doc = " byte value value."]
    #[doc = ""]
    #[doc = "  hipMemsetAsync() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  value - Value to set for each byte of specified memory"]
    #[doc = "  @param[in]  sizeBytes - Size in bytes to set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemsetAsync(
        dst: *mut ::libc::c_void,
        value: ::libc::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dev with the constant integer"]
    #[doc = " value for specified number of times."]
    #[doc = ""]
    #[doc = "  hipMemsetD32Async() is asynchronous with respect to the host, so the call may return before the"]
    #[doc = " memset is complete. The operation can optionally be associated to a stream by passing a non-zero"]
    #[doc = " stream argument. If stream is non-zero, the operation may overlap with operations in other"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  value - Value to set for each byte of specified memory"]
    #[doc = "  @param[in]  count - number of values to be set"]
    #[doc = "  @param[in]  stream - Stream identifier"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemsetD32Async(
        dst: hipDeviceptr_t,
        value: ::libc::c_int,
        count: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills the memory area pointed to by dst with the constant value."]
    #[doc = ""]
    #[doc = "  @param[out] dst Pointer to device memory"]
    #[doc = "  @param[in]  pitch - data size in bytes"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  width"]
    #[doc = "  @param[in]  height"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset2D(
        dst: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by dst with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in]  dst Pointer to device memory"]
    #[doc = "  @param[in]  pitch - data size in bytes"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  width"]
    #[doc = "  @param[in]  height"]
    #[doc = "  @param[in]  stream"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset2DAsync(
        dst: *mut ::libc::c_void,
        pitch: usize,
        value: ::libc::c_int,
        width: usize,
        height: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills synchronously the memory area pointed to by pitchedDevPtr with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in] pitchedDevPtr"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  extent"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset3D(
        pitchedDevPtr: hipPitchedPtr,
        value: ::libc::c_int,
        extent: hipExtent,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Fills asynchronously the memory area pointed to by pitchedDevPtr with the constant value."]
    #[doc = ""]
    #[doc = "  @param[in] pitchedDevPtr"]
    #[doc = "  @param[in]  value - constant value to be set"]
    #[doc = "  @param[in]  extent"]
    #[doc = "  @param[in]  stream"]
    #[doc = "  @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryFree"]
    pub fn hipMemset3DAsync(
        pitchedDevPtr: hipPitchedPtr,
        value: ::libc::c_int,
        extent: hipExtent,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Query memory info."]
    #[doc = " Return snapshot of free memory, and total allocatable memory on the device."]
    #[doc = ""]
    #[doc = " Returns in *free a snapshot of the current free memory."]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue"]
    #[doc = " @warning On HCC, the free memory only accounts for memory allocated by this process and may be"]
    #[doc = "optimistic."]
    pub fn hipMemGetInfo(free: *mut usize, total: *mut usize) -> hipError_t;
}
extern "C" {
    pub fn hipMemPtrGetInfo(ptr: *mut ::libc::c_void, size: *mut usize) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device."]
    #[doc = ""]
    #[doc = "  @param[out]  array  Pointer to allocated array in device memory"]
    #[doc = "  @param[in]   desc   Requested channel format"]
    #[doc = "  @param[in]   width  Requested array allocation width"]
    #[doc = "  @param[in]   height Requested array allocation height"]
    #[doc = "  @param[in]   flags  Requested properties of allocated array"]
    #[doc = "  @return      #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMallocArray(
        array: *mut *mut hipArray,
        desc: *const hipChannelFormatDesc,
        width: usize,
        height: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipArrayCreate(
        pHandle: *mut *mut hipArray,
        pAllocateArray: *const HIP_ARRAY_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipArray3DCreate(
        array: *mut *mut hipArray,
        pAllocateArray: *const HIP_ARRAY3D_DESCRIPTOR,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipMalloc3D(pitchedDevPtr: *mut hipPitchedPtr, extent: hipExtent) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Frees an array on the device."]
    #[doc = ""]
    #[doc = "  @param[in]  array  Pointer to array to free"]
    #[doc = "  @return     #hipSuccess, #hipErrorInvalidValue, #hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipMallocArray, hipHostMalloc, hipHostFree"]
    pub fn hipFreeArray(array: *mut hipArray) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees a mipmapped array on the device"]
    #[doc = ""]
    #[doc = " @param[in] mipmappedArray - Pointer to mipmapped array to free"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipFreeMipmappedArray(mipmappedArray: hipMipmappedArray_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Allocate an array on the device."]
    #[doc = ""]
    #[doc = "  @param[out]  array  Pointer to allocated array in device memory"]
    #[doc = "  @param[in]   desc   Requested channel format"]
    #[doc = "  @param[in]   extent Requested array allocation width, height and depth"]
    #[doc = "  @param[in]   flags  Requested properties of allocated array"]
    #[doc = "  @return      #hipSuccess, #hipErrorOutOfMemory"]
    #[doc = ""]
    #[doc = "  @see hipMalloc, hipMallocPitch, hipFree, hipFreeArray, hipHostMalloc, hipHostFree"]
    pub fn hipMalloc3DArray(
        array: *mut *mut hipArray,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Allocate a mipmapped array on the device"]
    #[doc = ""]
    #[doc = " @param[out] mipmappedArray  - Pointer to allocated mipmapped array in device memory"]
    #[doc = " @param[in]  desc            - Requested channel format"]
    #[doc = " @param[in]  extent          - Requested allocation size (width field in elements)"]
    #[doc = " @param[in]  numLevels       - Number of mipmap levels to allocate"]
    #[doc = " @param[in]  flags           - Flags for extensions"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue, #hipErrorMemoryAllocation"]
    pub fn hipMallocMipmappedArray(
        mipmappedArray: *mut hipMipmappedArray_t,
        desc: *const hipChannelFormatDesc,
        extent: hipExtent,
        numLevels: ::libc::c_uint,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets a mipmap level of a HIP mipmapped array"]
    #[doc = ""]
    #[doc = " @param[out] levelArray     - Returned mipmap level HIP array"]
    #[doc = " @param[in]  mipmappedArray - HIP mipmapped array"]
    #[doc = " @param[in]  level          - Mipmap level"]
    #[doc = ""]
    #[doc = " @return #hipSuccess, #hipErrorInvalidValue"]
    pub fn hipGetMipmappedArrayLevel(
        levelArray: *mut hipArray_t,
        mipmappedArray: hipMipmappedArray_const_t,
        level: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2D(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays."]
    #[doc = "  @param[in]   pCopy Parameters for the memory copy"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2D(pCopy: *const hip_Memcpy2D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies memory for 2D arrays."]
    #[doc = "  @param[in]   pCopy Parameters for the memory copy"]
    #[doc = "  @param[in]   stream Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2D, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray,"]
    #[doc = " hipMemcpyToSymbol, hipMemcpyAsync"]
    pub fn hipMemcpyParam2DAsync(pCopy: *const hip_Memcpy2D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @param[in]   stream Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2DToArray, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DAsync(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpyToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DToArray(
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        spitch: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst    Destination memory address"]
    #[doc = "  @param[in]   dpitch Pitch of destination memory"]
    #[doc = "  @param[in]   src    Source memory address"]
    #[doc = "  @param[in]   spitch Pitch of source memory"]
    #[doc = "  @param[in]   width  Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind   Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyToArray(
        dst: *mut hipArray,
        wOffset: usize,
        hOffset: usize,
        src: *const ::libc::c_void,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   srcArray  Source memory address"]
    #[doc = "  @param[in]   woffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   count     Size in bytes to copy"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyFromArray(
        dst: *mut ::libc::c_void,
        srcArray: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        count: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   dpitch    Pitch of destination memory"]
    #[doc = "  @param[in]   src       Source memory address"]
    #[doc = "  @param[in]   wOffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   width     Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height    Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArray(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   dpitch    Pitch of destination memory"]
    #[doc = "  @param[in]   src       Source memory address"]
    #[doc = "  @param[in]   wOffset   Source starting X offset"]
    #[doc = "  @param[in]   hOffset   Source starting Y offset"]
    #[doc = "  @param[in]   width     Width of matrix transfer (columns in bytes)"]
    #[doc = "  @param[in]   height    Height of matrix transfer (rows)"]
    #[doc = "  @param[in]   kind      Type of transfer"]
    #[doc = "  @param[in]   stream    Accelerator view which the copy is being enqueued"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy2DFromArrayAsync(
        dst: *mut ::libc::c_void,
        dpitch: usize,
        src: hipArray_const_t,
        wOffset: usize,
        hOffset: usize,
        width: usize,
        height: usize,
        kind: hipMemcpyKind,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dst       Destination memory address"]
    #[doc = "  @param[in]   srcArray  Source array"]
    #[doc = "  @param[in]   srcoffset Offset in bytes of source array"]
    #[doc = "  @param[in]   count     Size of memory copy in bytes"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyAtoH(
        dst: *mut ::libc::c_void,
        srcArray: *mut hipArray,
        srcOffset: usize,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   dstArray   Destination memory address"]
    #[doc = "  @param[in]   dstOffset  Offset in bytes of destination array"]
    #[doc = "  @param[in]   srcHost    Source host pointer"]
    #[doc = "  @param[in]   count      Size of memory copy in bytes"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpyHtoA(
        dstArray: *mut hipArray,
        dstOffset: usize,
        srcHost: *const ::libc::c_void,
        count: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   p   3D memory copy parameters"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy3D(p: *const hipMemcpy3DParms) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   p        3D memory copy parameters"]
    #[doc = "  @param[in]   stream   Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = " #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipMemcpy3DAsync(p: *const hipMemcpy3DParms, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device."]
    #[doc = ""]
    #[doc = "  @param[in]   pCopy   3D memory copy parameters"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipDrvMemcpy3D(pCopy: *const HIP_MEMCPY3D) -> hipError_t;
}
extern "C" {
    #[doc = "  @brief Copies data between host and device asynchronously."]
    #[doc = ""]
    #[doc = "  @param[in]   pCopy    3D memory copy parameters"]
    #[doc = "  @param[in]   stream   Stream to use"]
    #[doc = "  @return      #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidPitchValue,"]
    #[doc = "  #hipErrorInvalidDevicePointer, #hipErrorInvalidMemcpyDirection"]
    #[doc = ""]
    #[doc = "  @see hipMemcpy, hipMemcpy2DToArray, hipMemcpy2D, hipMemcpyFromArray, hipMemcpyToSymbol,"]
    #[doc = " hipMemcpyAsync"]
    pub fn hipDrvMemcpy3DAsync(pCopy: *const HIP_MEMCPY3D, stream: hipStream_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Determine if a device can access a peer's memory."]
    #[doc = ""]
    #[doc = " @param [out] canAccessPeer Returns the peer access capability (0 or 1)"]
    #[doc = " @param [in] device - device from where memory may be accessed."]
    #[doc = " @param [in] peerDevice - device where memory is physically located"]
    #[doc = ""]
    #[doc = " Returns \"1\" in @p canAccessPeer if the specified @p device is capable"]
    #[doc = " of directly accessing memory physically located on peerDevice , or \"0\" if not."]
    #[doc = ""]
    #[doc = " Returns \"0\" in @p canAccessPeer if deviceId == peerDeviceId, and both are valid devices : a"]
    #[doc = " device is not a peer of itself."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess,"]
    #[doc = " @returns #hipErrorInvalidDevice if deviceId or peerDeviceId are not valid devices"]
    pub fn hipDeviceCanAccessPeer(
        canAccessPeer: *mut ::libc::c_int,
        deviceId: ::libc::c_int,
        peerDeviceId: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enable direct access from current device's virtual address space to memory allocations"]
    #[doc = " physically located on a peer device."]
    #[doc = ""]
    #[doc = " Memory which already allocated on peer device will be mapped into the address space of the"]
    #[doc = " current device.  In addition, all future memory allocations on peerDeviceId will be mapped into"]
    #[doc = " the address space of the current device when the memory is allocated. The peer memory remains"]
    #[doc = " accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] peerDeviceId"]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " Returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,"]
    #[doc = " @returns #hipErrorPeerAccessAlreadyEnabled if peer access is already enabled for this device."]
    pub fn hipDeviceEnablePeerAccess(
        peerDeviceId: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current device's virtual address space to memory allocations"]
    #[doc = " physically located on a peer device."]
    #[doc = ""]
    #[doc = " Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been"]
    #[doc = " enabled from the current device."]
    #[doc = ""]
    #[doc = " @param [in] peerDeviceId"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    pub fn hipDeviceDisablePeerAccess(peerDeviceId: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get information on memory allocations."]
    #[doc = ""]
    #[doc = " @param [out] pbase - BAse pointer address"]
    #[doc = " @param [out] psize - Size of allocation"]
    #[doc = " @param [in]  dptr- Device Pointer"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevicePointer"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipMemGetAddressRange(
        pbase: *mut hipDeviceptr_t,
        psize: *mut usize,
        dptr: hipDeviceptr_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device."]
    #[doc = ""]
    #[doc = " @param [out] dst - Destination device pointer."]
    #[doc = " @param [in] dstDeviceId - Destination device"]
    #[doc = " @param [in] src - Source device pointer"]
    #[doc = " @param [in] srcDeviceId - Source device"]
    #[doc = " @param [in] sizeBytes - Size of memory copy in bytes"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeer(
        dst: *mut ::libc::c_void,
        dstDeviceId: ::libc::c_int,
        src: *const ::libc::c_void,
        srcDeviceId: ::libc::c_int,
        sizeBytes: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Copies memory from one device to memory on another device."]
    #[doc = ""]
    #[doc = " @param [out] dst - Destination device pointer."]
    #[doc = " @param [in] dstDevice - Destination device"]
    #[doc = " @param [in] src - Source device pointer"]
    #[doc = " @param [in] srcDevice - Source device"]
    #[doc = " @param [in] sizeBytes - Size of memory copy in bytes"]
    #[doc = " @param [in] stream - Stream identifier"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, #hipErrorInvalidDevice"]
    pub fn hipMemcpyPeerAsync(
        dst: *mut ::libc::c_void,
        dstDeviceId: ::libc::c_int,
        src: *const ::libc::c_void,
        srcDevice: ::libc::c_int,
        sizeBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Explicitly initializes the HIP runtime."]
    #[doc = ""]
    #[doc = " Most HIP APIs implicitly initialize the HIP runtime."]
    #[doc = " This API provides control over the timing of the initialization."]
    pub fn hipInit(flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Create a context and set it as current/ default context"]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = " @param [in] flags"]
    #[doc = " @param [in] associated device handle"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxPushCurrent,"]
    #[doc = " hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxCreate(
        ctx: *mut hipCtx_t,
        flags: ::libc::c_uint,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Destroy a HIP context."]
    #[doc = ""]
    #[doc = " @param [in] ctx Context to destroy"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,hipCtxSetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxDestroy(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Pop the current/default context and return the popped context."]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxSetCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxPopCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Push the context to be set as current/ default context"]
    #[doc = ""]
    #[doc = " @param [in] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxPushCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set the passed context as current/default"]
    #[doc = ""]
    #[doc = " @param [in] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize , hipCtxGetDevice"]
    pub fn hipCtxSetCurrent(ctx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the current/ default context"]
    #[doc = ""]
    #[doc = " @param [out] ctx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetCurrent(ctx: *mut hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the handle of the device associated with current/default context"]
    #[doc = ""]
    #[doc = " @param [out] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidContext"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize"]
    pub fn hipCtxGetDevice(device: *mut hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP api version."]
    #[doc = ""]
    #[doc = " @param [in]  ctx Context to check"]
    #[doc = " @param [out] apiVersion"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning The HIP feature set does not correspond to an exact CUDA SDK api revision."]
    #[doc = " This function always set *apiVersion to 4 as an approximation though HIP supports"]
    #[doc = " some features which were introduced in later CUDA SDK revisions."]
    #[doc = " HIP apps code should not rely on the api revision number here and should"]
    #[doc = " use arch feature flags to test device capabilities or conditional compilation."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetDevice, hipCtxGetFlags, hipCtxPopCurrent,"]
    #[doc = " hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetApiVersion(ctx: hipCtx_t, apiVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Cache configuration for a specific function"]
    #[doc = ""]
    #[doc = " @param [out] cacheConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetCacheConfig(cacheConfig: *mut hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set L1/Shared cache partition."]
    #[doc = ""]
    #[doc = " @param [in] cacheConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support reconfigurable cache.  This hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxSetCacheConfig(cacheConfig: hipFuncCache_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set Shared memory bank configuration."]
    #[doc = ""]
    #[doc = " @param [in] sharedMemoryConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxSetSharedMemConfig(config: hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get Shared memory bank configuration."]
    #[doc = ""]
    #[doc = " @param [out] sharedMemoryConfiguration"]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning AMD devices and some Nvidia GPUS do not support shared cache banking, and the hint is"]
    #[doc = " ignored on those architectures."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetSharedMemConfig(pConfig: *mut hipSharedMemConfig) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Blocks until the default context has completed all preceding requested tasks."]
    #[doc = ""]
    #[doc = " @return #hipSuccess"]
    #[doc = ""]
    #[doc = " @warning This function waits for all streams on the default context to complete execution, and"]
    #[doc = " then returns."]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxGetDevice"]
    pub fn hipCtxSynchronize() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Return flags used for creating default context."]
    #[doc = ""]
    #[doc = " @param [out] flags"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxPopCurrent, hipCtxGetCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipCtxGetFlags(flags: *mut ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Enables direct access to memory allocations in a peer context."]
    #[doc = ""]
    #[doc = " Memory which already allocated on peer device will be mapped into the address space of the"]
    #[doc = " current device.  In addition, all future memory allocations on peerDeviceId will be mapped into"]
    #[doc = " the address space of the current device when the memory is allocated. The peer memory remains"]
    #[doc = " accessible from the current device until a call to hipDeviceDisablePeerAccess or hipDeviceReset."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] peerCtx"]
    #[doc = " @param [in] flags"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidDevice, #hipErrorInvalidValue,"]
    #[doc = " #hipErrorPeerAccessAlreadyEnabled"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning PeerToPeer support is experimental."]
    pub fn hipCtxEnablePeerAccess(peerCtx: hipCtx_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Disable direct access from current context's virtual address space to memory allocations"]
    #[doc = " physically located on a peer context.Disables direct access to memory allocations in a peer"]
    #[doc = " context and unregisters any registered allocations."]
    #[doc = ""]
    #[doc = " Returns hipErrorPeerAccessNotEnabled if direct access to memory on peerDevice has not yet been"]
    #[doc = " enabled from the current device."]
    #[doc = ""]
    #[doc = " @param [in] peerCtx"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorPeerAccessNotEnabled"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning PeerToPeer support is experimental."]
    pub fn hipCtxDisablePeerAccess(peerCtx: hipCtx_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Get the state of the primary context."]
    #[doc = ""]
    #[doc = " @param [in] Device to get primary context flags for"]
    #[doc = " @param [out] Pointer to store flags"]
    #[doc = " @param [out] Pointer to store context state; 0 = inactive, 1 = active"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxGetState(
        dev: hipDevice_t,
        flags: *mut ::libc::c_uint,
        active: *mut ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Release the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [in] Device which primary context is released"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    #[doc = " @warning This function return #hipSuccess though doesn't release the primaryCtx by design on"]
    #[doc = " HIP/HCC path."]
    pub fn hipDevicePrimaryCtxRelease(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Retain the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [out] Returned context handle of the new context"]
    #[doc = " @param [in] Device which primary context is released"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxRetain(pctx: *mut hipCtx_t, dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Resets the primary context on the GPU."]
    #[doc = ""]
    #[doc = " @param [in] Device which primary context is reset"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxReset(dev: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set flags for the primary context."]
    #[doc = ""]
    #[doc = " @param [in] Device for which the primary context flags are set"]
    #[doc = " @param [in] New flags for the device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorContextAlreadyInUse"]
    #[doc = ""]
    #[doc = " @see hipCtxCreate, hipCtxDestroy, hipCtxGetFlags, hipCtxPopCurrent, hipCtxGetCurrent,"]
    #[doc = " hipCtxSetCurrent, hipCtxPushCurrent, hipCtxSetCacheConfig, hipCtxSynchronize, hipCtxGetDevice"]
    pub fn hipDevicePrimaryCtxSetFlags(dev: hipDevice_t, flags: ::libc::c_uint) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device"]
    #[doc = " @param [out] device"]
    #[doc = " @param [in] ordinal"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGet(device: *mut hipDevice_t, ordinal: ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the compute capability of the device"]
    #[doc = " @param [out] major"]
    #[doc = " @param [out] minor"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceComputeCapability(
        major: *mut ::libc::c_int,
        minor: *mut ::libc::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns an identifer string for the device."]
    #[doc = " @param [out] name"]
    #[doc = " @param [in] len"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGetName(
        name: *mut ::libc::c_char,
        len: ::libc::c_int,
        device: hipDevice_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a PCI Bus Id string for the device, overloaded to take int device ID."]
    #[doc = " @param [out] pciBusId"]
    #[doc = " @param [in] len"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceGetPCIBusId(
        pciBusId: *mut ::libc::c_char,
        len: ::libc::c_int,
        device: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns a handle to a compute device."]
    #[doc = " @param [out] device handle"]
    #[doc = " @param [in] PCI Bus ID"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice, #hipErrorInvalidValue"]
    pub fn hipDeviceGetByPCIBusId(
        device: *mut ::libc::c_int,
        pciBusId: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the total amount of memory on the device."]
    #[doc = " @param [out] bytes"]
    #[doc = " @param [in] device"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidDevice"]
    pub fn hipDeviceTotalMem(bytes: *mut usize, device: hipDevice_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP driver version."]
    #[doc = ""]
    #[doc = " @param [out] driverVersion"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidValue"]
    #[doc = ""]
    #[doc = " @warning The HIP feature set does not correspond to an exact CUDA SDK driver revision."]
    #[doc = " This function always set *driverVersion to 4 as an approximation though HIP supports"]
    #[doc = " some features which were introduced in later CUDA SDK revisions."]
    #[doc = " HIP apps code should not rely on the driver revision number here and should"]
    #[doc = " use arch feature flags to test device capabilities or conditional compilation."]
    #[doc = ""]
    #[doc = " @see hipRuntimeGetVersion"]
    pub fn hipDriverGetVersion(driverVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns the approximate HIP Runtime version."]
    #[doc = ""]
    #[doc = " @param [out] runtimeVersion"]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInavlidValue"]
    #[doc = ""]
    #[doc = " @warning On HIP/HCC path this function returns HIP runtime patch version however on"]
    #[doc = " HIP/NVCC path this function return CUDA runtime version."]
    #[doc = ""]
    #[doc = " @see hipDriverGetVersion"]
    pub fn hipRuntimeGetVersion(runtimeVersion: *mut ::libc::c_int) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Loads code object from file into a hipModule_t"]
    #[doc = ""]
    #[doc = " @param [in] fname"]
    #[doc = " @param [out] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorFileNotFound,"]
    #[doc = " hipErrorOutOfMemory, hipErrorSharedObjectInitFailed, hipErrorNotInitialized"]
    #[doc = ""]
    #[doc = ""]
    pub fn hipModuleLoad(module: *mut hipModule_t, fname: *const ::libc::c_char) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Frees the module"]
    #[doc = ""]
    #[doc = " @param [in] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidValue"]
    #[doc = " module is freed and the code objects associated with it are destroyed"]
    #[doc = ""]
    pub fn hipModuleUnload(module: hipModule_t) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Function with kname will be extracted if present in module"]
    #[doc = ""]
    #[doc = " @param [in] module"]
    #[doc = " @param [in] kname"]
    #[doc = " @param [out] function"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidContext, hipErrorNotInitialized,"]
    #[doc = " hipErrorNotFound,"]
    pub fn hipModuleGetFunction(
        function: *mut hipFunction_t,
        module: hipModule_t,
        kname: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out attributes for a given function."]
    #[doc = ""]
    #[doc = " @param [out] attr"]
    #[doc = " @param [in] func"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttributes(
        attr: *mut hipFuncAttributes,
        func: *const ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Find out a specific attribute for a given function."]
    #[doc = ""]
    #[doc = " @param [out] value"]
    #[doc = " @param [in]  attrib"]
    #[doc = " @param [in]  hfunc"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorInvalidValue, hipErrorInvalidDeviceFunction"]
    pub fn hipFuncGetAttribute(
        value: *mut ::libc::c_int,
        attrib: hipFunction_attribute,
        hfunc: hipFunction_t,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipModuleGetTexRef(
        texRef: *mut *mut textureReference,
        hmod: hipModule_t,
        name: *const ::libc::c_char,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that"]
    #[doc = " location."]
    #[doc = ""]
    #[doc = " @param [in] image"]
    #[doc = " @param [out] module"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadData(module: *mut hipModule_t, image: *const ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief builds module from code object which resides in host memory. Image is pointer to that"]
    #[doc = " location. Options are not used. hipModuleLoadData is called."]
    #[doc = ""]
    #[doc = " @param [in] image"]
    #[doc = " @param [out] module"]
    #[doc = " @param [in] number of options"]
    #[doc = " @param [in] options for JIT"]
    #[doc = " @param [in] option values for JIT"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipErrorNotInitialized, hipErrorOutOfMemory, hipErrorNotInitialized"]
    pub fn hipModuleLoadDataEx(
        module: *mut hipModule_t,
        image: *const ::libc::c_void,
        numOptions: ::libc::c_uint,
        options: *mut hipJitOption,
        optionValues: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief launches kernel f with launch parameters and shared memory on stream with arguments passed"]
    #[doc = " to kernelparams or extra"]
    #[doc = ""]
    #[doc = " @param [in] f         Kernel to launch."]
    #[doc = " @param [in] gridDimX  X grid dimension specified as multiple of blockDimX."]
    #[doc = " @param [in] gridDimY  Y grid dimension specified as multiple of blockDimY."]
    #[doc = " @param [in] gridDimZ  Z grid dimension specified as multiple of blockDimZ."]
    #[doc = " @param [in] blockDimX X block dimensions specified in work-items"]
    #[doc = " @param [in] blockDimY Y grid dimension specified in work-items"]
    #[doc = " @param [in] blockDimZ Z grid dimension specified in work-items"]
    #[doc = " @param [in] sharedMemBytes Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = " kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case th"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = " @param [in] kernelParams"]
    #[doc = " @param [in] extra     Pointer to kernel arguments.   These are passed directly to the kernel and"]
    #[doc = " must be in the memory layout and alignment expected by the kernel."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @warning kernellParams argument is not yet implemented in HIP. Please use extra instead. Please"]
    #[doc = " refer to hip_porting_driver_api.md for sample usage."]
    pub fn hipModuleLaunchKernel(
        f: hipFunction_t,
        gridDimX: ::libc::c_uint,
        gridDimY: ::libc::c_uint,
        gridDimZ: ::libc::c_uint,
        blockDimX: ::libc::c_uint,
        blockDimY: ::libc::c_uint,
        blockDimZ: ::libc::c_uint,
        sharedMemBytes: ::libc::c_uint,
        stream: hipStream_t,
        kernelParams: *mut *mut ::libc::c_void,
        extra: *mut *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (only default supported)"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipModuleOccupancyMaxPotentialBlockSizeWithFlags(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: hipFunction_t,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  func             Kernel function (hipFunction) for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::libc::c_int,
        f: hipFunction_t,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  f                Kernel function(hipFunction_t) for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (only default supported)"]
    pub fn hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::libc::c_int,
        f: hipFunction_t,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  func             Kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessor(
        numBlocks: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Returns occupancy for a device function."]
    #[doc = ""]
    #[doc = " @param [out] numBlocks        Returned occupancy"]
    #[doc = " @param [in]  f                Kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  blockSize        Block size the kernel is intended to be launched with"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  flags            Extra flags for occupancy calculation (currently ignored)"]
    pub fn hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(
        numBlocks: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        blockSize: ::libc::c_int,
        dynSharedMemPerBlk: usize,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief determine the grid and block sizes to achieves maximum occupancy for a kernel"]
    #[doc = ""]
    #[doc = " @param [out] gridSize           minimum grid size for maximum potential occupancy"]
    #[doc = " @param [out] blockSize          block size for maximum potential occupancy"]
    #[doc = " @param [in]  f                  kernel function for which occupancy is calulated"]
    #[doc = " @param [in]  dynSharedMemPerBlk dynamic shared memory usage (in bytes) intended for each block"]
    #[doc = " @param [in]  blockSizeLimit     the maximum block size for the kernel, use 0 for no limit"]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorInvalidValue"]
    pub fn hipOccupancyMaxPotentialBlockSize(
        gridSize: *mut ::libc::c_int,
        blockSize: *mut ::libc::c_int,
        f: *const ::libc::c_void,
        dynSharedMemPerBlk: usize,
        blockSizeLimit: ::libc::c_int,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launches kernels on multiple devices and guarantees all specified kernels are dispatched"]
    #[doc = " on respective streams before enqueuing any other work on the specified streams from any other threads"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] hipLaunchParams          List of launch parameters, one per device."]
    #[doc = " @param [in] numDevices               Size of the launchParamsList array."]
    #[doc = " @param [in] flags                    Flags to control launch behavior."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    pub fn hipExtLaunchMultiKernelMultiDevice(
        launchParamsList: *mut hipLaunchParams,
        numDevices: ::libc::c_int,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Start recording of profiling information"]
    #[doc = " When using this API, start the profiler with profiling disabled.  (--startdisabled)"]
    #[doc = " @warning : hipProfilerStart API is under development."]
    pub fn hipProfilerStart() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Stop recording of profiling information."]
    #[doc = " When using this API, start the profiler with profiling disabled.  (--startdisabled)"]
    #[doc = " @warning : hipProfilerStop API is under development."]
    pub fn hipProfilerStop() -> hipError_t;
}
extern "C" {
    #[doc = " @brief Gets an interprocess memory handle for an existing device memory"]
    #[doc = "          allocation"]
    #[doc = ""]
    #[doc = " Takes a pointer to the base of an existing device memory allocation created"]
    #[doc = " with hipMalloc and exports it for use in another process. This is a"]
    #[doc = " lightweight operation and may be called multiple times on an allocation"]
    #[doc = " without adverse effects."]
    #[doc = ""]
    #[doc = " If a region of memory is freed with hipFree and a subsequent call"]
    #[doc = " to hipMalloc returns memory with the same device address,"]
    #[doc = " hipIpcGetMemHandle will return a unique handle for the"]
    #[doc = " new memory."]
    #[doc = ""]
    #[doc = " @param handle - Pointer to user allocated hipIpcMemHandle to return"]
    #[doc = "                    the handle in."]
    #[doc = " @param devPtr - Base pointer to previously allocated device memory"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = " hipErrorOutOfMemory,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = ""]
    pub fn hipIpcGetMemHandle(
        handle: *mut hipIpcMemHandle_t,
        devPtr: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Opens an interprocess memory handle exported from another process"]
    #[doc = "          and returns a device pointer usable in the local process."]
    #[doc = ""]
    #[doc = " Maps memory exported from another process with hipIpcGetMemHandle into"]
    #[doc = " the current device address space. For contexts on different devices"]
    #[doc = " hipIpcOpenMemHandle can attempt to enable peer access between the"]
    #[doc = " devices as if the user called hipDeviceEnablePeerAccess. This behavior is"]
    #[doc = " controlled by the hipIpcMemLazyEnablePeerAccess flag."]
    #[doc = " hipDeviceCanAccessPeer can determine if a mapping is possible."]
    #[doc = ""]
    #[doc = " Contexts that may open hipIpcMemHandles are restricted in the following way."]
    #[doc = " hipIpcMemHandles from each device in a given process may only be opened"]
    #[doc = " by one context per device per other process."]
    #[doc = ""]
    #[doc = " Memory returned from hipIpcOpenMemHandle must be freed with"]
    #[doc = " hipIpcCloseMemHandle."]
    #[doc = ""]
    #[doc = " Calling hipFree on an exported memory region before calling"]
    #[doc = " hipIpcCloseMemHandle in the importing context will result in undefined"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param devPtr - Returned device pointer"]
    #[doc = " @param handle - hipIpcMemHandle to open"]
    #[doc = " @param flags  - Flags for this operation. Must be specified as hipIpcMemLazyEnablePeerAccess"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = " hipErrorTooManyPeers"]
    #[doc = ""]
    #[doc = " @note No guarantees are made about the address returned in @p *devPtr."]
    #[doc = " In particular, multiple processes may not receive the same address for the same @p handle."]
    #[doc = ""]
    pub fn hipIpcOpenMemHandle(
        devPtr: *mut *mut ::libc::c_void,
        handle: hipIpcMemHandle_t,
        flags: ::libc::c_uint,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Close memory mapped with hipIpcOpenMemHandle"]
    #[doc = ""]
    #[doc = " Unmaps memory returnd by hipIpcOpenMemHandle. The original allocation"]
    #[doc = " in the exporting process as well as imported mappings in other processes"]
    #[doc = " will be unaffected."]
    #[doc = ""]
    #[doc = " Any resources used to enable peer access will be freed if this is the"]
    #[doc = " last mapping using them."]
    #[doc = ""]
    #[doc = " @param devPtr - Device pointer returned by hipIpcOpenMemHandle"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = " hipSuccess,"]
    #[doc = " hipErrorMapFailed,"]
    #[doc = " hipErrorInvalidHandle,"]
    #[doc = ""]
    pub fn hipIpcCloseMemHandle(devPtr: *mut ::libc::c_void) -> hipError_t;
}
extern "C" {
    pub fn hipIpcGetEventHandle(handle: *mut hipIpcEventHandle_t, event: hipEvent_t) -> hipError_t;
}
extern "C" {
    pub fn hipIpcOpenEventHandle(event: *mut hipEvent_t, handle: hipIpcEventHandle_t)
        -> hipError_t;
}
extern "C" {
    #[doc = " @brief Configure a kernel launch."]
    #[doc = ""]
    #[doc = " @param [in] gridDim   grid dimension specified as multiple of blockDim."]
    #[doc = " @param [in] blockDim  block dimensions specified in work-items"]
    #[doc = " @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = " kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn hipConfigureCall(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Set a kernel argument."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    #[doc = " @param [in] arg    Pointer the argument in host memory."]
    #[doc = " @param [in] size   Size of the argument."]
    #[doc = " @param [in] offset Offset of the argument on the argument stack."]
    #[doc = ""]
    pub fn hipSetupArgument(arg: *const ::libc::c_void, size: usize, offset: usize) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Launch a kernel."]
    #[doc = ""]
    #[doc = " @param [in] func Kernel to launch."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn hipLaunchByPtr(func: *const ::libc::c_void) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Push configuration of a kernel launch."]
    #[doc = ""]
    #[doc = " @param [in] gridDim   grid dimension specified as multiple of blockDim."]
    #[doc = " @param [in] blockDim  block dimensions specified in work-items"]
    #[doc = " @param [in] sharedMem Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = " kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [in] stream    Stream where the kernel should be dispatched.  May be 0, in which case the"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn __hipPushCallConfiguration(
        gridDim: dim3,
        blockDim: dim3,
        sharedMem: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief Pop configuration of a kernel launch."]
    #[doc = ""]
    #[doc = " @param [out] gridDim   grid dimension specified as multiple of blockDim."]
    #[doc = " @param [out] blockDim  block dimensions specified in work-items"]
    #[doc = " @param [out] sharedMem Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = " kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [out] stream    Stream where the kernel should be dispatched.  May be 0, in which case the"]
    #[doc = " default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns hipSuccess, hipInvalidDevice, hipErrorNotInitialized, hipErrorInvalidValue"]
    #[doc = ""]
    pub fn __hipPopCallConfiguration(
        gridDim: *mut dim3,
        blockDim: *mut dim3,
        sharedMem: *mut usize,
        stream: *mut hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " @brief C compliant kernel launch API"]
    #[doc = ""]
    #[doc = " @param [in] function_address - kernel stub function pointer."]
    #[doc = " @param [in] numBlocks - number of blocks"]
    #[doc = " @param [in] dimBlocks - dimension of a block"]
    #[doc = " @param [in] args - kernel arguments"]
    #[doc = " @param [in] sharedMemBytes - Amount of dynamic shared memory to allocate for this kernel.  The"]
    #[doc = "  Kernel can access this with HIP_DYNAMIC_SHARED."]
    #[doc = " @param [in] stream - Stream where the kernel should be dispatched.  May be 0, in which case th"]
    #[doc = "  default stream is used with associated synchronization rules."]
    #[doc = ""]
    #[doc = " @returns #hipSuccess, #hipErrorInvalidValue, hipInvalidDevice"]
    #[doc = ""]
    pub fn hipLaunchKernel(
        function_address: *const ::libc::c_void,
        numBlocks: dim3,
        dimBlocks: dim3,
        args: *mut *mut ::libc::c_void,
        sharedMemBytes: usize,
        stream: hipStream_t,
    ) -> hipError_t;
}
extern "C" {
    #[doc = " Callback/Activity API"]
    pub fn hipRegisterApiCallback(
        id: u32,
        fun: *mut ::libc::c_void,
        arg: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipRemoveApiCallback(id: u32) -> hipError_t;
}
extern "C" {
    pub fn hipRegisterActivityCallback(
        id: u32,
        fun: *mut ::libc::c_void,
        arg: *mut ::libc::c_void,
    ) -> hipError_t;
}
extern "C" {
    pub fn hipRemoveActivityCallback(id: u32) -> hipError_t;
}
extern "C" {
    pub fn hipApiName(id: u32) -> *const ::libc::c_char;
}
extern "C" {
    pub fn hipKernelNameRef(f: hipFunction_t) -> *const ::libc::c_char;
}
extern "C" {
    pub fn hipKernelNameRefByPtr(
        hostFunction: *const ::libc::c_void,
        stream: hipStream_t,
    ) -> *const ::libc::c_char;
}
pub type hipblasHandle_t = *mut ::libc::c_void;
pub type hipblasHalf = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasBfloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_hipblasBfloat16() {
    assert_eq!(
        ::std::mem::size_of::<hipblasBfloat16>(),
        2usize,
        concat!("Size of: ", stringify!(hipblasBfloat16))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasBfloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(hipblasBfloat16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasBfloat16>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasBfloat16),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasComplex {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_hipblasComplex() {
    assert_eq!(
        ::std::mem::size_of::<hipblasComplex>(),
        8usize,
        concat!("Size of: ", stringify!(hipblasComplex))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasComplex>(),
        4usize,
        concat!("Alignment of ", stringify!(hipblasComplex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasComplex>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasComplex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasComplex>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasComplex),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hipblasDoubleComplex {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_hipblasDoubleComplex() {
    assert_eq!(
        ::std::mem::size_of::<hipblasDoubleComplex>(),
        16usize,
        concat!("Size of: ", stringify!(hipblasDoubleComplex))
    );
    assert_eq!(
        ::std::mem::align_of::<hipblasDoubleComplex>(),
        8usize,
        concat!("Alignment of ", stringify!(hipblasDoubleComplex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasDoubleComplex>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasDoubleComplex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hipblasDoubleComplex>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasDoubleComplex),
            "::",
            stringify!(y)
        )
    );
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasStatus_t {
    HIPBLAS_STATUS_SUCCESS = 0,
    HIPBLAS_STATUS_NOT_INITIALIZED = 1,
    HIPBLAS_STATUS_ALLOC_FAILED = 2,
    HIPBLAS_STATUS_INVALID_VALUE = 3,
    HIPBLAS_STATUS_MAPPING_ERROR = 4,
    HIPBLAS_STATUS_EXECUTION_FAILED = 5,
    HIPBLAS_STATUS_INTERNAL_ERROR = 6,
    HIPBLAS_STATUS_NOT_SUPPORTED = 7,
    HIPBLAS_STATUS_ARCH_MISMATCH = 8,
    HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasOperation_t {
    HIPBLAS_OP_N = 111,
    HIPBLAS_OP_T = 112,
    HIPBLAS_OP_C = 113,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasPointerMode_t {
    HIPBLAS_POINTER_MODE_HOST = 0,
    HIPBLAS_POINTER_MODE_DEVICE = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasFillMode_t {
    HIPBLAS_FILL_MODE_UPPER = 121,
    HIPBLAS_FILL_MODE_LOWER = 122,
    HIPBLAS_FILL_MODE_FULL = 123,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasDiagType_t {
    HIPBLAS_DIAG_NON_UNIT = 131,
    HIPBLAS_DIAG_UNIT = 132,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasSideMode_t {
    HIPBLAS_SIDE_LEFT = 141,
    HIPBLAS_SIDE_RIGHT = 142,
    HIPBLAS_SIDE_BOTH = 143,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasDatatype_t {
    #[doc = "< 16 bit floating point, real"]
    HIPBLAS_R_16F = 150,
    #[doc = "< 32 bit floating point, real"]
    HIPBLAS_R_32F = 151,
    #[doc = "< 64 bit floating point, real"]
    HIPBLAS_R_64F = 152,
    #[doc = "< 16 bit floating point, complex"]
    HIPBLAS_C_16F = 153,
    #[doc = "< 32 bit floating point, complex"]
    HIPBLAS_C_32F = 154,
    #[doc = "< 64 bit floating point, complex"]
    HIPBLAS_C_64F = 155,
    #[doc = "<  8 bit signed integer, real"]
    HIPBLAS_R_8I = 160,
    #[doc = "<  8 bit unsigned integer, real"]
    HIPBLAS_R_8U = 161,
    #[doc = "< 32 bit signed integer, real"]
    HIPBLAS_R_32I = 162,
    #[doc = "< 32 bit unsigned integer, real"]
    HIPBLAS_R_32U = 163,
    #[doc = "<  8 bit signed integer, complex"]
    HIPBLAS_C_8I = 164,
    #[doc = "<  8 bit unsigned integer, complex"]
    HIPBLAS_C_8U = 165,
    #[doc = "< 32 bit signed integer, complex"]
    HIPBLAS_C_32I = 166,
    #[doc = "< 32 bit unsigned integer, complex"]
    HIPBLAS_C_32U = 167,
    #[doc = "< 16 bit bfloat, real"]
    HIPBLAS_R_16B = 168,
    #[doc = "< 16 bit bfloat, complex"]
    HIPBLAS_C_16B = 169,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hipblasGemmAlgo_t {
    HIPBLAS_GEMM_DEFAULT = 160,
}
extern "C" {
    pub fn hipblasCreate(handle: *mut hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDestroy(handle: hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSetStream(handle: hipblasHandle_t, streamId: hipStream_t) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGetStream(handle: hipblasHandle_t, streamId: *mut hipStream_t)
        -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSetPointerMode(
        handle: hipblasHandle_t,
        mode: hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGetPointerMode(
        handle: hipblasHandle_t,
        mode: *mut hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSetVector(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        x: *const ::libc::c_void,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGetVector(
        n: ::libc::c_int,
        elemSize: ::libc::c_int,
        x: *const ::libc::c_void,
        incx: ::libc::c_int,
        y: *mut ::libc::c_void,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSetMatrix(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGetMatrix(
        rows: ::libc::c_int,
        cols: ::libc::c_int,
        elemSize: ::libc::c_int,
        A: *const ::libc::c_void,
        lda: ::libc::c_int,
        B: *mut ::libc::c_void,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeam(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        B: *const f32,
        ldb: ::libc::c_int,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeam(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        B: *const f64,
        ldb: ::libc::c_int,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamax(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamax(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamaxBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamin(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamin(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsaminBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasum(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasum(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasumBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::libc::c_int,
        y: *mut hipblasHalf,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasHalf,
        x: *const *const hipblasHalf,
        incx: ::libc::c_int,
        y: *const *mut hipblasHalf,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *mut f32,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *mut f64,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasHalf,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasHalf,
        incx: ::libc::c_int,
        y: *const hipblasHalf,
        incy: ::libc::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasBfloat16,
        incx: ::libc::c_int,
        y: *const hipblasBfloat16,
        incy: ::libc::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasHalf,
        incx: ::libc::c_int,
        y: *const *const hipblasHalf,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasBfloat16,
        incx: ::libc::c_int,
        y: *const *const hipblasBfloat16,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *const f32,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *const f64,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasHalf,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasHalf,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasBfloat16,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasBfloat16,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batch_count: ::libc::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2Batched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2Batched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        y: *const *mut f32,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        y: *const *mut f64,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotg(
        handle: hipblasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotg(
        handle: hipblasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        b: *mut hipblasComplex,
        c: *mut f32,
        s: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        b: *mut hipblasDoubleComplex,
        c: *mut f64,
        s: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f32,
        b: *const *mut f32,
        c: *const *mut f32,
        s: *const *mut f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f64,
        b: *const *mut f64,
        c: *const *mut f64,
        s: *const *mut f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasComplex,
        b: *const *mut hipblasComplex,
        c: *const *mut f32,
        s: *const *mut hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasDoubleComplex,
        b: *const *mut hipblasDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f32,
        stride_a: ::libc::c_int,
        b: *mut f32,
        stride_b: ::libc::c_int,
        c: *mut f32,
        stride_c: ::libc::c_int,
        s: *mut f32,
        stride_s: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f64,
        stride_a: ::libc::c_int,
        b: *mut f64,
        stride_b: ::libc::c_int,
        c: *mut f64,
        stride_c: ::libc::c_int,
        s: *mut f64,
        stride_s: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        stride_a: ::libc::c_int,
        b: *mut hipblasComplex,
        stride_b: ::libc::c_int,
        c: *mut f32,
        stride_c: ::libc::c_int,
        s: *mut hipblasComplex,
        stride_s: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        stride_a: ::libc::c_int,
        b: *mut hipblasDoubleComplex,
        stride_b: ::libc::c_int,
        c: *mut f64,
        stride_c: ::libc::c_int,
        s: *mut hipblasDoubleComplex,
        stride_s: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotm(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        param: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotm(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        param: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        y: *const *mut f32,
        incy: ::libc::c_int,
        param: *const *const f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        y: *const *mut f64,
        incy: ::libc::c_int,
        param: *const *const f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        param: *const f32,
        stride_param: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        param: *const f64,
        stride_param: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmg(
        handle: hipblasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmg(
        handle: hipblasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f32,
        d2: *const *mut f32,
        x1: *const *mut f32,
        y1: *const *const f32,
        param: *const *mut f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f64,
        d2: *const *mut f64,
        x1: *const *mut f64,
        y1: *const *const f64,
        param: *const *mut f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f32,
        stride_d1: ::libc::c_int,
        d2: *mut f32,
        stride_d2: ::libc::c_int,
        x1: *mut f32,
        stride_x1: ::libc::c_int,
        y1: *const f32,
        stride_y1: ::libc::c_int,
        param: *mut f32,
        stride_param: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f64,
        stride_d1: ::libc::c_int,
        d2: *mut f64,
        stride_d2: ::libc::c_int,
        x1: *mut f64,
        stride_x1: ::libc::c_int,
        y1: *const f64,
        stride_y1: ::libc::c_int,
        param: *mut f64,
        stride_param: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswap(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswap(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswapBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut *mut f32,
        incx: ::libc::c_int,
        y: *mut *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut *mut f64,
        incx: ::libc::c_int,
        y: *mut *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut *mut hipblasComplex,
        incx: ::libc::c_int,
        y: *mut *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *mut *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        kl: ::libc::c_int,
        ku: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        stridey: ::libc::c_int,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        stridey: ::libc::c_int,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSger(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDger(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgerBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *const f32,
        incy: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *const f64,
        incy: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        da: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stride_y: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        strideAP: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut hipblasComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        AP: *mut hipblasComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        AP: *const f32,
        strideAP: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        AP: *const f64,
        strideAP: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        AP: *const *mut f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        AP: *const *mut f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut f32,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut f64,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut hipblasComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        AP: *mut hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *const f32,
        incy: ::libc::c_int,
        AP: *const *mut f32,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *const f64,
        incy: ::libc::c_int,
        AP: *const *mut f64,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        AP: *mut f32,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        AP: *mut f64,
        strideAP: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *const f32,
        incx: ::libc::c_int,
        beta: *const f32,
        y: *mut *mut f32,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *const f64,
        incx: ::libc::c_int,
        beta: *const f64,
        y: *mut *mut f64,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut *mut hipblasComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        stirdeA: ::libc::c_int,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        stirdeA: ::libc::c_int,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stirdeA: ::libc::c_int,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stirdeA: ::libc::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        stridey: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::libc::c_int,
        y: *const *const f32,
        incy: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::libc::c_int,
        y: *const *const f64,
        incy: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f32,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const f64,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::libc::c_int,
        stridey: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        k: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f32,
        strideAP: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stride: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f64,
        strideAP: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stride: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasComplex,
        strideAP: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stride: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f32,
        strideAP: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const f64,
        strideAP: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasComplex,
        strideAP: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        AP: *const hipblasDoubleComplex,
        strideAP: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        stride_a: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stride_x: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const f32,
        lda: ::libc::c_int,
        x: *const *mut f32,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const f64,
        lda: ::libc::c_int,
        x: *const *mut f64,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *mut f32,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *mut f64,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *mut hipblasComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::libc::c_int,
        stridex: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f32,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f64,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        strideC: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        stridec: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        stridec: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        stridec: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        stridec: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *mut f32,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *mut f64,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *mut f32,
        lda: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *mut f64,
        lda: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *const *mut f32,
        lda: ::libc::c_int,
        B: *mut *mut f32,
        ldb: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *const *mut f64,
        lda: ::libc::c_int,
        B: *mut *mut f64,
        ldb: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        B: *mut *mut hipblasComplex,
        ldb: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *mut *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f32,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const f64,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrf(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrf(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrf(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrf(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrfBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut ::libc::c_int,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *const *mut f32,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *const *mut f64,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        strideP: ::libc::c_int,
        B: *mut f32,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        strideP: ::libc::c_int,
        B: *mut f64,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        strideP: ::libc::c_int,
        B: *mut hipblasComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::libc::c_int,
        nrhs: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *const ::libc::c_int,
        strideP: ::libc::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::libc::c_int,
        strideB: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeqrf(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        ipiv: *mut f32,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrf(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        ipiv: *mut f64,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrf(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *mut hipblasComplex,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrf(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *mut hipblasDoubleComplex,
        info: *mut ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const *mut f32,
        lda: ::libc::c_int,
        ipiv: *const *mut f32,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const *mut f64,
        lda: ::libc::c_int,
        ipiv: *const *mut f64,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const *mut hipblasComplex,
        lda: ::libc::c_int,
        ipiv: *const *mut hipblasComplex,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        ipiv: *const *mut hipblasDoubleComplex,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut f32,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut f32,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut f64,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut f64,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut hipblasComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut hipblasComplex,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::libc::c_int,
        strideA: ::libc::c_int,
        ipiv: *mut hipblasDoubleComplex,
        strideP: ::libc::c_int,
        info: *mut ::libc::c_int,
        batch_count: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasHalf,
        A: *const hipblasHalf,
        lda: ::libc::c_int,
        B: *const hipblasHalf,
        ldb: ::libc::c_int,
        beta: *const hipblasHalf,
        C: *mut hipblasHalf,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        B: *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        B: *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasHalf,
        A: *const *const hipblasHalf,
        lda: ::libc::c_int,
        B: *const *const hipblasHalf,
        ldb: ::libc::c_int,
        beta: *const hipblasHalf,
        C: *const *mut hipblasHalf,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::libc::c_int,
        B: *const *const f32,
        ldb: ::libc::c_int,
        beta: *const f32,
        C: *const *mut f32,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::libc::c_int,
        B: *const *const f64,
        ldb: ::libc::c_int,
        beta: *const f64,
        C: *const *mut f64,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasComplex,
        C: *const *mut hipblasComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        beta: *const hipblasDoubleComplex,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasHalf,
        A: *const hipblasHalf,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const hipblasHalf,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const hipblasHalf,
        C: *mut hipblasHalf,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const f32,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const f32,
        C: *mut f32,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const f64,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const f64,
        C: *mut f64,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const hipblasComplex,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const hipblasComplex,
        C: *mut hipblasComplex,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched(
        handle: hipblasHandle_t,
        transa: hipblasOperation_t,
        transb: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::libc::c_int,
        bsa: ::libc::c_longlong,
        B: *const hipblasDoubleComplex,
        ldb: ::libc::c_int,
        bsb: ::libc::c_longlong,
        beta: *const hipblasDoubleComplex,
        C: *mut hipblasDoubleComplex,
        ldc: ::libc::c_int,
        bsc: ::libc::c_longlong,
        batchCount: ::libc::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmEx(
        handle: hipblasHandle_t,
        trans_a: hipblasOperation_t,
        trans_b: hipblasOperation_t,
        m: ::libc::c_int,
        n: ::libc::c_int,
        k: ::libc::c_int,
        alpha: *const ::libc::c_void,
        a: *const ::libc::c_void,
        a_type: hipblasDatatype_t,
        lda: ::libc::c_int,
        b: *const ::libc::c_void,
        b_type: hipblasDatatype_t,
        ldb: ::libc::c_int,
        beta: *const ::libc::c_void,
        c: *mut ::libc::c_void,
        c_type: hipblasDatatype_t,
        ldc: ::libc::c_int,
        compute_type: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
